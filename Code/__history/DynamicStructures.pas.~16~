unit DynamicStructures;

interface

type
  // Тип односвязного списка с целыми числами
  TPItem = ^TItem;

  TItem = record
    Number: Integer;
    Next: TPItem;
  end;

  // Тип стека с целыми числами
  TStack = TPItem;

  // Тип очереди с целыми числами
  TQueue = record
    Head: TPItem;
    Tail: TPItem;
  end;

  // Подпрограмма инициализации стека
procedure InitializeStack(var Stack: TStack);

// Подпрограмма инициализации очереди
procedure InitializeQueue(var Queue: TQueue);

// Подпрограмма очищения списка
procedure DestroyList(var Head: TPItem);

// Подпрограмма вставки в стек
procedure Push(var Stack: TStack; n: Integer);

// Подпрограмма добавления в очередь
procedure Enqueue(var Queue: TQueue; n: Integer);

// Подпрограмма извлечения из стека
function Pop(var Stack: TStack): Integer;

// Подпрограмма извлечения из очереди
function Dequeue(var Queue: TQueue): Integer;

implementation

procedure InitializeStack(var Stack: TStack);
begin

  // Зануление указателя на голову
  Stack := nil;
end;

procedure InitializeQueue(var Queue: TQueue);
begin

  // Зануление указателей на голову и хвост
  Queue.Head := nil;
  Queue.Tail := nil;
end;

procedure DestroyList(var Head: TPItem);
var
  Item: TPItem;
begin
  // Цикл А1. Освобождение списка
  while Head <> nil do
  begin
    Item := Head;
    Head := Head.Next;
    Dispose(Item);
  end; // Конец А1
end;

procedure Push(var Stack: TStack; n: Integer);
var
  Item: TPItem; // Вставляемое звено списка
begin
  New(Item);
  Item.Number := n;
  Item.Next := Stack;
  Stack := Item;
end;

procedure Enqueue(var Queue: TQueue; n: Integer);
var
  Item: TPItem; // Вставляемое звено списка
begin

  // Инициализация нового элемента
  New(Item);
  Item.Number := n;
  Item.Next := nil;

  // Сохранение нового элемента
  if Queue.Head <> nil then
    Queue.Tail.Next := Item
  else
    Queue.Head := Item;

  // Перемещение хвоста
  Queue.Tail := Item;
end;

function Pop(var Stack: TStack): Integer;
var
  Item: TPItem; // Извлекаемое звено списка
begin

  if Stack <> nil then
  begin
    // Перемещение вершины стека
    Item := Stack;
    Stack := Stack.Next;

    // Извлечение элемента с очисткой указателя
    Result := Item.Number;
    Dispose(Item);
  end
  else
    Result := 0; // Ошибка при извлечении

end;

function Dequeue(var Queue: TQueue): Integer;
var
  Item: TPItem; // Извлекаемое звено списка
begin
  if Queue.Head <> nil then
  begin

    // Перемещение начала очереди
    Item := Queue.Head;
    Queue.Head := Queue.Head.Next;

    // Извлечение элемента с очисткой указателя
    Result := Item.Number;
    Dispose(Item);
  end
  else
    Result := 0; // Ошибка при извлечении
end;

end.
