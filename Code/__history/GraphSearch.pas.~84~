unit GraphSearch;

interface

uses Digraph, DynStructures;

type
  // Тип матрицы весов
  TWeights = array of array of Integer;
  TSearchInfo = record
    Distance: Integer;
    ArcsCount: Integer;
    Path: TStack;
  end;

  { Процедура преобразования графа в матрицу весов }
procedure ToWeightMatrix(const G: TGraph; out Matrix: TWeights);

{ Процедура поиска в глубину }
procedure DFS(const Graph: TWeights; const Src, Dest: Integer;
  out Info: TSearchInfo);

{ Процедура поиска в ширину }
procedure BFS(const Graph: TWeights; const Src, Dest: Integer;
   out Info: TSearchInfo);

{ Процедура поиска алгоритмом Дейкстры }
procedure Dijkstra(const Graph: TWeights; const Src, Dest: Integer;
   out Info: TSearchInfo);

implementation

const
  INF = 1000000000;

  { Процедура восстановления пути по массиву предков }
procedure RestorePath(const Parents: array of Integer; const Src, Dest: Integer;
  out Path: TStack);
var
  v: Integer;
begin

  InitializeStack(Path); // Инициализация стека
  v := Dest; // Сохранение конца пути

  // Цикл А1. Добавление очередного предка в пути
  while (v <> Src) and (v <> 0) do
  begin
    Push(Path, v);
    v := Parents[v - 1];
  end; // Конец А1

  Push(Path, v);

  // Случай, если путь не был найден
  if v = 0 then
    DestroyList(Path);
end;

procedure DFS(const Graph: TWeights; const Src, Dest: Integer;
   out Info: TSearchInfo);
var
  v, u: Integer;
  Order: Integer;
  s: TStack;
  isUsed: Array of Boolean;
  Parents: Array of Integer;
begin

  Order := Length(Graph); // Получение порядка графа
  v := Src; // Сохранение старта

  // Подготовка стека
  InitializeStack(s);
  Push(s, v);

  // Подготовка меток
  SetLength(isUsed, Order);
  for u := 1 to Order do
    isUsed[u - 1] := False;

  // Подготовка массива предков
  SetLength(Parents, Order);
  Parents[v - 1] := 0;

  // Цикл А1. Посещение вершин в стеке
  while s <> nil do
  begin

    // Получение вершины
    v := Pop(s);
    if not isUsed[v - 1] then
    begin
      isUsed[v - 1] := true;

      // Цикл А2. Добавление в стек всех соседей вершины
      for u := Order downto 1 do
      begin
        if not isUsed[u - 1] and (Graph[v - 1, u - 1] <> INF) then
        begin
          Parents[u - 1] := v;
          Push(s, u);
        end; // Конец if

      end; // Конец А2

    end;

  end; // Конец А1

  // Восстановление пути
  RestorePath(Parents, Src, Dest, Path);
end;

procedure BFS(const Graph: TWeights; const Src, Dest: Integer;
   out Info: TSearchInfo);
var
  v, u: Integer;
  Order: Integer;
  q: TQueue;
  isUsed: Array of Boolean;
  Parents: Array of Integer;
begin

  Order := Length(Graph); // Получение порядка графа
  v := Src; // Сохранение старта

  // Подготовка стека
  InitializeQueue(q);
  Enqueue(q, v);

  // Подготовка меток
  SetLength(isUsed, Order);
  for u := 1 to Order do
    isUsed[u - 1] := False;
  isUsed[v - 1] := true;

  // Подготовка массива предков
  SetLength(Parents, Order);
  Parents[v - 1] := 0;

  // Цикл А1. Посещение всех вершин из очереди
  while q.Head <> nil do
  begin

    // Получение вершины
    v := Dequeue(q);

    // Цикл А2. Добавление в стек всех соседей вершины
    for u := 1 to Order do
    begin
      if not isUsed[u - 1] and (Graph[v - 1, u - 1] <> INF) then
      begin
        isUsed[u - 1] := true;
        Parents[u - 1] := v;
        Enqueue(q, u);
      end; // Конец if

    end; // Конец А2

  end; // Конец А1

  // Восстановление пути
  RestorePath(Parents, Src, Dest, Path);

end;

procedure Dijkstra(const Graph: TWeights; const Src, Dest: Integer;
   out Info: TSearchInfo);
var
  v, u: Integer;
  Order: Integer;
  isVisited: Array of Boolean;
  Parents: Array of Integer;
  Marks: Array of Integer;
  isFound: Boolean;
  d: Integer;
  i: Integer;
begin

  Order := Length(Graph); // Получение порядка графа
  v := Src; // Сохранение старта

  // Подготовка массива расстояний
  SetLength(Marks, Order);
  for u := 1 to Order do
    Marks[u - 1] := INF;
  Marks[v - 1] := 0;

  // Подготовка массива меток
  SetLength(isVisited, Order);
  for u := 1 to Order do
    isVisited[u - 1] := False;

  // Подготовка массива предков
  SetLength(Parents, Order);
  Parents[v - 1] := 0;

  // Инициализация условий входа в цикл
  isFound := v = Dest;
  d := 0;

  // Цикл А1. Посещение вершин с минимальными расстояниями
  while not(isFound or (d = INF)) do
  begin

    // Цикл А2. Уменьшение меток
    for u := 1 to Order do
    begin
      if not isVisited[u - 1] and (Marks[u - 1] > d + Graph[v - 1, u - 1]) then
      begin
        Parents[u - 1] := v;
        Marks[u - 1] := d + Graph[v - 1, u - 1];
      end;
    end; // Конец А2

    // Посещение следущей вершины
    isVisited[v - 1] := true;
    isFound := v = Dest;

    d := INF;

    // Цикл А1. Поиск минимального элемента
    for i := Low(Marks) to High(Marks) do
    begin

      // Проверка посещённости и сравнение
      if not isVisited[i] and (Marks[i] < d) then
      begin
        d := Marks[i];
        v := i + 1;
      end; // Конец if

    end; // Конец А1

  end; // Конец А1

  // Восстановление пути
  RestorePath(Parents, Src, Dest, Path);

end;

{ Процедура преобразования графа в матрицу весов }
procedure ToWeightMatrix(const G: TGraph; out Matrix: TWeights);
var
  v, u: Integer;
  Vertice: TPVertice;
  Neighbour: TPNeighbour;
begin

  // Инициализация матрицы
  SetLength(Matrix, G.Order, G.Order);
  for v := 1 to G.Order do
    for u := 1 to G.Order do
      Matrix[v - 1, u - 1] := INF;

  // Цикл А2. Проход по вершинам
  Vertice := G.Head;
  while Vertice <> nil do
  begin

    // Цикл A3. Проход по соседям вершины
    Neighbour := Vertice.Head;
    while Neighbour <> nil do
    begin
      Matrix[Vertice.Number - 1, Neighbour.Number - 1] := Neighbour.Weight;
      Neighbour := Neighbour.Next;
    end;
    // Конец A3

    Vertice := Vertice.Next;
  end; // Конец A2
end;

end.
