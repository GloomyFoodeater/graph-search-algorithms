unit Digraph;

interface

uses System.Types, DynStructures, System.SysUtils;

const
  INFINITY = 1000000;

type

  // Тип списка смежности
  TAdjList = TPList;

  // Тип вершины графа
  TVertice = ^TVerticeNode;

  TVerticeNode = record
    Center: TPoint;
    Number: Integer;
    Head: TAdjList;
    Next: TVertice;
    Deg: Integer;
  end;

  // Тип ориентированный граф
  TGraph = record
    Head: TVertice;
    Tail: TVertice;
    Order: Integer;
  end;

  // Тип матрицы весов
  TWeights = array of array of Integer;

  { Процедура получения вершины по номеру }
procedure GetByNumber(const G: TGraph; v: Integer; out Vertice: TVertice);

{ Процедура нахождения вершины и её координаты по точке на холсте }
procedure Centralize(const G: TGraph; var P: TPoint; out v: Integer);

{ Функция получения центра вершины }
function GetCenter(const G: TGraph; v: Integer): TPoint;

{ Функция вычисления расстояния между двумя точками в пикселях }
function Distance(const p1, p2: TPoint): Integer;

{ Процедура добавления вершины в граф }
procedure AddNode(var G: TGraph; const C: TPoint);

{ Процедура добавления дуги в граф }
procedure AddLink(var G: TGraph; v, u: Integer);

{ Процедура удаления вершины из графа }
procedure DeleteNode(var G: TGraph; v: Integer);

{ Процедура удаления дуги из графа }
procedure DeleteLink(var G: TGraph; v, u: Integer);

{ Процедура инициализации графа }
procedure InitializeGraph(var G: TGraph);

{ Процедура очищения графа }
procedure DestroyGraph(var G: TGraph);

{ Процедура преобразования графа в матрицу весов }
procedure ToAdjMatrix(const G: TGraph; var Matrix: TWeights);

implementation

function Distance(const p1, p2: TPoint): Integer;
begin
  Result := Round(Sqrt(Sqr(p2.x - p1.x) + Sqr(p2.y - p1.y)));
end;

{ Функция нахождения вершины по номеру в списке }
procedure GetByNumber(const G: TGraph; v: Integer; out Vertice: TVertice);
begin
  Vertice := G.Head;

  // Цикл А1. Поиск вершины с данным номером
  while (Vertice <> nil) and (Vertice.Number <> v) do
  begin
    Vertice := Vertice.Next;
  end; // Конец А1

end;

procedure Centralize(const G: TGraph; var P: TPoint; out v: Integer);
var
  Vertice, Found: TVertice;
  isFound: Boolean;
begin
  Vertice := G.Head;
  isFound := False;
  Found := nil;

  // Цикл А1. Поиск последней вершины с близкими координатами
  while Vertice <> nil do
  begin
    isFound := Distance(Vertice.Center, P) <= 20;
    if isFound then
      Found := Vertice;
    Vertice := Vertice.Next;
  end; // Конец А1

  // Возврат найденной вершины
  if Found <> nil then
  begin
    v := Found.Number;
    P := Found.Center;
  end
  else
    v := 0; // Вершина не была найдена
end;

function GetCenter(const G: TGraph; v: Integer): TPoint;
var
  Vertice: TVertice;
begin
  GetByNumber(G, v, Vertice);
  if Vertice <> nil then
    Result := Vertice.Center;
end;

procedure AddNode(var G: TGraph; const C: TPoint);
var
  Vertice: TVertice;
begin
  Inc(G.Order);

  // Инициализация новой вершины
  New(Vertice);
  with Vertice^ do
  begin
    Center := C;
    Number := G.Order;
    Head := nil;
    Next := nil;
    Deg := 0;
  end;

  // Инициализация указателя на новую вершину
  if G.Head = nil then
    G.Head := Vertice
  else
    G.Tail.Next := Vertice;

  // Перезапись хвоста
  G.Tail := Vertice;

end;

procedure AddLink(var G: TGraph; v, u: Integer);
var
  Vertice: TVertice;
  PrevArc, CurrArc: TAdjList;
  isFound: Boolean;
begin

  // Получение вершины
  GetByNumber(G, v, Vertice);
  Inc(Vertice.Deg);

  // Инициализация нового соседа
  New(CurrArc);
  CurrArc.Elem := u;

  // Получение начального соседа
  PrevArc := Vertice.Head;

  // Список смежности был пуст или голова была больше нового соседа
  if (PrevArc = nil) or (PrevArc.Elem > u) then
  begin
    CurrArc.Next := PrevArc;
    Vertice.Head := CurrArc;
  end
  else
  begin

    // Цикл А1. Поиск места вставки (предыдущего соседа)
    isFound := (PrevArc.Next = nil) or (PrevArc.Next.Elem > u);
    while not isFound do
    begin
      PrevArc := PrevArc.Next;
      isFound := (PrevArc.Next = nil) or (PrevArc.Next.Elem > u);
    end; // Конец А1

    // Вставка нового соседа
    CurrArc.Next := PrevArc.Next;
    PrevArc.Next := CurrArc;

  end; // Конец if

end;

procedure DeleteNode(var G: TGraph; v: Integer);
var
  PrevVertice, Vertice: TVertice;
  PrevArc, Arc: TPList;

begin
  Dec(G.Order);

  // Цикл А1. Проход по вершинам
  PrevVertice := nil;
  Vertice := G.Head;
  while Vertice <> nil do
  begin

    // Проверка номера вершины
    if Vertice.Number = v then
    begin

      // Переназначение предыдущего указателя
      if PrevVertice = nil then
        G.Head := Vertice.Next
      else
        PrevVertice.Next := Vertice.Next;

      // Освобождение списка смежности
      DestroyList(Vertice.Head);
      Dispose(Vertice);
    end // Конец if
    else
    begin

      // Уменьшение всех вершин, больших удаляемой на 1
      if Vertice.Number > v then
        Dec(Vertice.Number);

      // Цикл А2. Проход по соседям вершины
      PrevArc := nil;
      Arc := Vertice.Head;
      while Arc <> nil do
      begin

        // Проверка номера соседа
        if Arc.Elem = v then
        begin

          // Переназначение предыдущего указателя
          if PrevArc = nil then
            Vertice.Head := Arc.Next
          else
            PrevArc.Next := Arc.Next;

          // Освобождение памяти звена списка
          Dispose(Arc);
        end // Конец if
        else if Arc.Elem > v then
          Dec(Arc.Elem);

        // Переход к следующему соседу
        PrevArc := Arc;
        Arc := Arc.Next;

      end; // Конец А2

    end; // Конец else

    // Переход к следующей вершине
    if Vertice.Next <> nil then
      PrevVertice := Vertice;
    Vertice := Vertice.Next;
  end; // Конец А1

  // Переназначение хвоста списка
  G.Tail := PrevVertice;
end;

procedure DeleteLink(var G: TGraph; v, u: Integer);
var
  Vertice: TVertice;
  Arc: TPList;
  DelNeighbour: TPList;
  isFound: Boolean;
begin

  // Получение начала дуги
  GetByNumber(G, v, Vertice);

  Dec(Vertice.Deg);

  // Получение первого соседа
  Arc := Vertice.Head;

  // Поиск звена перед звеном с искомым соседом
  if (Arc = nil) or (Arc.Elem = u) then
  begin
    DelNeighbour := Arc;
    if DelNeighbour <> nil then
      Vertice.Head := DelNeighbour.Next
    else
      Vertice.Head := nil;
  end
  else
  begin

    isFound := (Arc.Next.Elem = u) or (Arc = nil);

    // Получение предыдущего соседа удаляемого
    while not isFound do
    begin
      Arc := Arc.Next;
      isFound := (Arc = nil) or (Arc.Next.Elem = u);
    end;

    DelNeighbour := Arc.Next;
    Arc.Next := DelNeighbour.Next;
  end;

  // Удаление соседа
  if not(DelNeighbour = nil) then
  begin
    Dispose(DelNeighbour);
  end;

end;

procedure InitializeGraph(var G: TGraph);
begin
  G.Head := nil;
  G.Tail := nil;
  G.Order := 0;
end;

procedure DestroyGraph(var G: TGraph);
var
  Vertice: TVertice;
begin

  // Цикл А1. Освобождение списка вершин
  while G.Head <> nil do
  begin
    Vertice := G.Head;

    // Цикл А2. Освобождение списка соседей вершины
    DestroyList(Vertice.Head);

    G.Head := G.Head.Next;
    Dispose(Vertice);
  end; // Конец А1
end;

procedure ToAdjMatrix;
var
  i, j: Integer;
  Vertice: TVertice;
  Arc: TPList;
begin

  // Инициализация матрицы
  SetLength(Matrix, G.Order, G.Order);

  // Цикл А1. Проход по вершинам
  Vertice := G.Head;
  for i := 0 to G.Order - 1 do
  begin

    // Цикл А2. Проход по соседям
    Arc := Vertice.Head;
    for j := 0 to G.Order - 1 do
    begin

      // Проверка смежности вершин
      if (Arc <> nil) and (Arc.Elem = j + 1) then
      begin

        // Вершины были смежны
        Matrix[i, j] := 1;

        // Переход к следующему соседу
        Arc := Arc.Next;
      end
      else
        Matrix[i, j] := INFINITY;
      // Вершины не были смежными
    end; // Конец А2
    // Matrix[i, i] := 0;

    // Переход к следующей вершине
    Vertice := Vertice.Next;
  end; // Конец А1
end;

end.
