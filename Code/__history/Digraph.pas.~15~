unit Digraph;

interface

uses System.Types;

type
  // Тип списка смежности
  TPAdjList = ^TAdjList;

  TAdjList = record
    Elem: Integer;
    Next: TPAdjList;
  end;

  // Тип вершинs графа
  TPNode = ^TNode;

  TNode = record
    Center: TPoint;
    Number: Cardinal;
    Head: TPAdjList;
    Tail: TPAdjList;
    Next: TPNode;
  end;

  // Тип простой граф
  TGraph = record
    Head: TPNode;
    Tail: TPNode;
    VG: Cardinal;
  end;

  { Функция нахождения вершины по номеру в списке }
function GetByNumber(const G: TGraph; v: Integer): TPNode;

{ Функция нахождения вершины по точке на холсте }
function GetByPoint(const G: TGraph; P: TPoint): TPNode;

{ Функция вычисления расстояния между двумя точками в пикселях }
function Distance(const p1, p2: TPoint): Integer;

{ Процедура добавления вершины в граф }
procedure AddNode(var G: TGraph; const C: TPoint);

{ Процедура добавления рёбер в граф }
procedure AddLink(var G: TGraph; u, v: Integer);

implementation

{ Функция вычисления расстояния между двумя точками в пикселях }
function Distance(const p1, p2: TPoint): Integer;
begin
  Result := Round(Sqrt(Sqr(p2.x - p1.x) + Sqr(p2.y - p1.y)));
end;

{ Функция нахождения вершины по номеру в списке }
function GetByNumber;
var
  i: Integer;
begin
  Result := G.Head;
  for i := 1 to v - 1 do
  begin
    Result := Result.Next;
  end;

end;

{ Функция нахождения вершины по точке на холсте }
function GetByPoint;
var
  Node: TPNode;
  isFound: Boolean;
  x, y: Integer;
begin
  Node := G.Head;
  if Node <> nil then
  begin
    isFound := Distance(Node.Center, P) <= Sqr(20);
  end;

  while not isFound do
  begin
    Node := Node.Next;
    isFound := (Node = nil) or (Distance(Node.Center, P) <= Sqr(20));
  end;
  Result := Node;
end;

{ Процедура добавления вершины в граф }
procedure AddNode;
begin
  Inc(G.VG);

  // Инициализация указателя на новую вершину
  if G.Tail = nil then
    New(G.Tail)
  else
  begin
    New(G.Tail.Next);
    G.Tail := G.Tail.Next
  end;

  // Сохранение новой вершины
  with G.Tail^ do
  begin
    Center := C;
    Number := G.VG;
    Head := nil;
    Tail := nil;
    Next := nil;
  end;

  // Инициализация головы списка
  if G.VG = 1 then
    G.Head := G.Tail;

end;

{ Процедура добавления рёбер в граф }
procedure AddLink;
var
  Node: TPNode;
  i, Tmp: Integer;
begin

  // Получение инцидентной вершины
  Node := GetByNumber(G, u);

  with Node^ do
  begin

    // Инициализация указателя на соседа
    if Tail = nil then
      New(Tail)
    else
    begin
      New(Tail.Next);
      Tail := Tail.Next;
    end;

    // Инициализация головы списка соседей
    if Head = nil then
      Head := Tail;

    // Сохранение соседа
    Tail.Elem := v;
    Tail.Next := nil;

  end;

end;

end.
