unit MainUnit;

interface

uses
  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
  Dialogs, ExtCtrls, StdCtrls, Buttons, Menus, GraphSearch, Digraph,
  DynStructures;

type
  TForm1 = class(TForm)
    Panel1: TPanel;
    AddNodeBtn: TSpeedButton;
    AddLinkBtn: TSpeedButton;
    DeleteNodeBtn: TSpeedButton;
    DeleteLinkBtn: TSpeedButton;
    MainMenu1: TMainMenu;
    N1: TMenuItem;
    N2: TMenuItem;
    N3: TMenuItem;
    N4: TMenuItem;
    N5: TMenuItem;
    N6: TMenuItem;
    N7: TMenuItem;
    N8: TMenuItem;
    N9: TMenuItem;
    DFSBtn: TSpeedButton;
    BFSbtn: TSpeedButton;
    DijkstraBtn: TSpeedButton;
    Button1: TButton;
    procedure FormClick(Sender: TObject);
    procedure AddNodeBtnClick(Sender: TObject);
    procedure AddLinkBtnClick(Sender: TObject);
    procedure FormClose(Sender: TObject; var Action: TCloseAction);
    procedure DFSBtnClick(Sender: TObject);
    procedure Button1Click(Sender: TObject);
    procedure BFSbtnClick(Sender: TObject);
    procedure DeleteLinkBtnClick(Sender: TObject);
    procedure DeleteNodeBtnClick(Sender: TObject);
    procedure DijkstraBtnClick(Sender: TObject);
    procedure SaveGraph(Sender: TObject);
    procedure OpenGraph(Sender: TObject);
  private
    { Private declarations }
  public
    { Public declarations }
  end;

  // Тип режима работы с формой
  TClickState = (stAddNode, stAddLink, stDeleteNode, stDeleteLink, stDFS, stBFS,
    stDijkstra, stNone);

var
  Form1: TForm1;
  State: TClickState;
  G: TGraph;
  StartNode: Cardinal = 0;
  StartNodeCenter: TPoint;

implementation

{$R *.dfm}

{ Процедура вычисления координат концов ребра на холсте }
procedure GetLinkPoints(c1, c2: TPoint; var p: Array of TPoint);
var
  d: Integer;
begin
  d := Distance(c1, c2);

  p[0].x := Round(c2.x + 20 * (c1.x - c2.x) / d);
  p[0].y := Round(c2.y + 20 * (c1.y - c2.y) / d);

  p[1].x := Round(c1.x + 20 * (c2.x - c1.x) / d);
  p[1].y := Round(c1.y + 20 * (c2.y - c1.y) / d);

end;

{ Процедура рисования вершины графа }
procedure DrawNode(u: Integer; Center: TPoint);
var
  Caption: String; // Имя вершины
  PosX: Integer; // Левый верхний край текста
  Copy: Integer; // Копия номера вершины
begin

  // Получение имени вершины и его x-координаты
  Str(u, Caption);
  Copy := u;
  PosX := Center.x;
  while Copy <> 0 do
  begin
    Copy := Copy div 10;
    PosX := PosX - 4;
  end;

  // Вывод круга
  Form1.Canvas.Ellipse(Center.x - 20, Center.y - 20, Center.x + 20,
    Center.y + 20);

  // Вывод имени вершины
  Form1.Canvas.TextOut(PosX + 1, Center.y - 6, Caption);
end;

{ Процедура рисования ребра графа }
procedure DrawLink(G: TGraph; c1, c2: TPoint);
var
  d: Integer;
  Points: Array [1 .. 2] of TPoint;
begin
  d := Distance(c1, c2);
  if d > 20 then
  begin
    GetLinkPoints(c1, c2, Points);
    Form1.Canvas.Polyline(Points);

    Form1.Canvas.Ellipse(Points[1].x - 5, Points[1].y - 5, Points[1].x + 5,
      Points[1].y + 5);
  end;
end;

procedure RedrawGraph(const G: TGraph);
var
  AdjMatrix: TAdjMatrix;
  u, v: Cardinal;
begin
  Form1.Canvas.Pen.Color := clWhite;
  Form1.Canvas.Rectangle(0, 0, Form1.Width, Form1.Height);
  Form1.Canvas.Pen.Color := clBlack;
  ToAdjMatrix(G, AdjMatrix);
  if Length(AdjMatrix) = 0 then
    Exit;

  for u := 0 to G.Order - 1 do
  begin
    DrawNode(u + 1, GetCenter(G, u + 1));
    for v := 0 to G.Order - 1 do
    begin
      if AdjMatrix[u, v] <> INFINITY then
        DrawLink(G, GetCenter(G, u + 1), GetCenter(G, v + 1));

    end;
  end;

end;

// Событие нажатия на холст
procedure TForm1.FormClick(Sender: TObject);
var
  Pos: TPoint;
  EndNode: Cardinal;
  d: Integer;
  Path: TStack;
  sPath: String;
begin
  // Получение координаты курсора
  Pos := ScreenToClient(Mouse.CursorPos);
  case State of
    stAddNode: // Добавление вершины графа
      begin
        AddNode(G, Pos);
        DrawNode(G.Order, Pos);
      end;
    stAddLink:
      begin
        if StartNode = 0 then
        begin
          Centralize(G, Pos, StartNode);
          StartNodeCenter := Pos;
        end
        else
        begin
          Centralize(G, Pos, EndNode);
          if (EndNode <> 0) and (StartNode <> EndNode) then
          begin
            AddLink(G, StartNode, EndNode);
            DrawLink(G, StartNodeCenter, Pos);
            StartNode := 0;
            EndNode := 0;
          end;
        end;
      end;
    stDeleteNode:
      begin
        Centralize(G, Pos, StartNode);
        if StartNode <> 0 then
        begin
          DeleteNode(G, StartNode);
          RedrawGraph(G);
        end;
      end;
    stDeleteLink:
      begin
        if StartNode = 0 then
        begin
          Centralize(G, Pos, StartNode);
        end
        else
        begin
          Centralize(G, Pos, EndNode);
          if (EndNode <> 0) and (StartNode <> EndNode) then
          begin
            DeleteLink(G, StartNode, EndNode);
            RedrawGraph(G);
            StartNode := 0;
          end;
        end;
      end;
    stDFS, stBFS, stDijkstra:
      begin
        if StartNode = 0 then
        begin
          Centralize(G, Pos, StartNode);
          StartNodeCenter := Pos;
        end
        else
        begin
          Centralize(G, Pos, EndNode);
          if (EndNode <> 0) then
          begin

            // Получение пути с помощью алгоритма
            case State of
              stDFS:
                Path := DFS(G, StartNode, EndNode); // Поиск в глубину
              stBFS:
                Path := BFS(G, StartNode, EndNode); // Поиск в ширину
              stDijkstra:
                Path := Dijkstra(G, StartNode, EndNode); // Поиск в ширину
            end;

            if not isEmpty(Path) then
            begin

              // Запись вспомогательного сообщения
              sPath := 'Найденный путь из вершины ' + IntToStr(StartNode) +
                ' в вершину ' + IntToStr(EndNode) + ':'#13#10;

              // Получение 1-го элемента пути
              sPath := sPath + IntToStr(Pop(Path));
            end
            else

              // Вспомогательное сообщение о несуществовании пути
              sPath := 'Вершина ' + IntToStr(EndNode) +
                ' не достижима из вершины ' + IntToStr(StartNode) + '.';

            // Запись пути в строку
            while not isEmpty(Path) do
              sPath := sPath + '->' + IntToStr(Pop(Path));

            // Вывод пути
            MessageBox(Handle, PChar(sPath), PChar('Результаты поиска'), MB_OK);

            // Обнуление начальной и конечной вершины
            StartNode := 0;
          end;
        end;
      end;
  end;
end;

procedure TForm1.FormClose(Sender: TObject; var Action: TCloseAction);
begin
  DestroyGraph(G);
end;

procedure TForm1.OpenGraph(Sender: TObject);
var
  fVertices: File of TNode;
  fArcs: File of TItem;
  Node: TPNode;
  Neighbour: TPList;
  i: Integer;
  deg: Integer;
begin
  DestroyGraph(G);
  InitializeGraph(G);

  System.Assign(fVertices, 'Graph.ver');
  System.Assign(fArcs, 'Graph.arc');

  Reset(fVertices);
  Reset(fArcs);

  i := 0;
  while not Eof(fVertices) do
  begin

    // Чтение вершины из файла вершин
    if i = 0 then
    begin

      // Чтение головы списка вершин
      New(Node);
      Read(fVertices, Node^);
      G.Head := Node;
    end
    else
    begin

      // Чтение не головной вершины
      New(Node.Next);
      Node := Node.Next;
      Read(fVertices, Node^);
    end;

    // Чтение списка смежности
    New(Node.Head);
    if not Eof(fArcs) then
    begin
      Read(fArcs, Node.Head^);
      if Node.Head <> nil then
      begin
        Neighbour := Node.Head;
        while not Eof(fArcs) and (Neighbour.Next <> nil) do
        begin
          New(Neighbour.Next);
          Neighbour := Neighbour.Next;
          Read(fArcs, Neighbour^);
        end;
      end;

    end
    else
    begin
      Dispose(Node.Head);
      Node.Head := nil;
    end;

    Inc(i);
  end;

  G.Tail := Node;
  G.Order := i;
  RedrawGraph(G);
end;

procedure TForm1.SaveGraph(Sender: TObject);
var
  fVertices: File of TNode;
  fArcs: File of TItem;
  Node: TPNode;
  Neighbour: TPList;
begin
  System.Assign(fVertices, 'Graph.ver');
  System.Assign(fArcs, 'Graph.arc');

  Rewrite(fVertices);
  Rewrite(fArcs);

  Node := G.Head;
  while Node <> nil do
  begin
    Write(fVertices, Node^);
    Neighbour := Node.Head;
    while Neighbour <> nil do
    begin
      Write(fArcs, Neighbour^);
      Neighbour := Neighbour.Next;
    end;
    Node := Node.Next;
  end;
end;

procedure TForm1.DijkstraBtnClick(Sender: TObject);
begin
  StartNode := 0;
  if DijkstraBtn.Down then
    State := stDijkstra
  else
    State := stNone;
end;

procedure TForm1.DeleteNodeBtnClick(Sender: TObject);
begin
  StartNode := 0;
  if DeleteNodeBtn.Down then
    State := stDeleteNode
  else
    State := stNone;
end;

procedure TForm1.DeleteLinkBtnClick(Sender: TObject);
begin
  StartNode := 0;
  if DeleteLinkBtn.Down then
    State := stDeleteLink
  else
    State := stNone;
end;

procedure TForm1.BFSbtnClick(Sender: TObject);
begin
  StartNode := 0;
  if BFSbtn.Down then
    State := stBFS
  else
    State := stNone;
end;

procedure TForm1.DFSBtnClick(Sender: TObject);
begin
  StartNode := 0;
  if DFSBtn.Down then
    State := stDFS
  else
    State := stNone;
end;

procedure TForm1.AddLinkBtnClick(Sender: TObject);
begin
  StartNode := 0;
  if AddLinkBtn.Down then
    State := stAddLink
  else
    State := stNone;
end;

procedure TForm1.AddNodeBtnClick(Sender: TObject);
begin
  StartNode := 0;
  if AddNodeBtn.Down then
    State := stAddNode
  else
    State := stNone;
end;

procedure TForm1.Button1Click(Sender: TObject);
const
  p: Array [1 .. 5] of TPoint = ((x: 300; y: 300), (x: 200; y: 400), (x: 400;
    y: 400), (x: 300; y: 500), (x: 300; y: 100));
var
  i: Integer;
begin
  InitializeGraph(G);
  for i := 1 to 5 do
  begin
    AddNode(G, p[i]);
    DrawNode(i, p[i]);
  end;
  for i := 2 to 5 do
  begin
    AddLink(G, 1, i);
    DrawLink(G, GetCenter(G, 1), GetCenter(G, i));
  end;
  Button1.Visible := false;
end;

end.
