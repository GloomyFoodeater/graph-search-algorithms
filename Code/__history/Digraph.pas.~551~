unit Digraph;

interface

uses System.Types, DynStructures, System.SysUtils, ComObj, Variants, ActiveX,
  Math, XMLIntf, XMLDoc, Vcl.ExtCtrls;

type

  // Тип перечисления стиля вершин
  TDesign = (dgPassive, dgActive, dgVisited);

  // Тип списка смежности
  TPNeighbour = ^TNeighbour;

  TNeighbour = record
    Number: Integer;
    Weight: Integer;
    isVisited: Boolean;
    Next: TPNeighbour;
  end;

  // Тип вершины графа
  TPVertice = ^TVertice;

  TVertice = record
    Center: TPoint;
    Number: Integer;
    Head: TPNeighbour;
    Next: TPVertice;
    Deg: Integer;
    Design: TDesign;
  end;

  // Тип ориентированный граф
  TGraph = record
    Head: TPVertice;
    Tail: TPVertice;
    Order: Integer;
    isPainted: Boolean;
    R: Integer;
  end;

  { Процедура инициализации графа }
procedure InitializeGraph(var G: TGraph);

{ Процедура очищения графа }
procedure DestroyGraph(var G: TGraph);

{ Процедура добавления вершины в граф }
procedure AddVertice(var G: TGraph; const C: TPoint);

{ Процедура добавления дуги в граф }
procedure AddArc(var G: TGraph; v, u: Integer; w: Integer);

{ Процедура удаления вершины из графа }
procedure DeleteVertice(var G: TGraph; v: Integer);

{ Процедура удаления дуги из графа }
procedure DeleteArc(var G: TGraph; v, u: Integer);

{ Процедура получения вершины по номеру }
procedure GetByNumber(const G: TGraph; v: Integer; out Vertice: TPVertice);

{ Процедура нахождения вершины по точке на холсте }
function Centralize(const G: TGraph; const P: TPoint;
  out Vertice: TPVertice): Boolean;

// Подпрограмма открытия графа из типизированных файлов
procedure OpenGraph(var G: TGraph; VerFileName, ArcFileName: String);

// Подпрограмма сохранения графа в типизированный файл
procedure SaveGraph(var G: TGraph; VerFileName, ArcFileName: String);

// Подпрограмма экспорта графа из экселя
procedure ImportFromExcel(var G: TGraph; FileName: String;
  Width, Height: Integer);

// TODO: Написать экспорт в Svg
procedure ExportToSvg(var G: TGraph; FileName: String);

{ Функция вычисления расстояния между двумя точками в пикселях }
function Distance(const p1, p2: TPoint): Integer;

implementation

function AreAdjacent(const G: TGraph; Vertice: TPVertice; u: Integer): Boolean;
var
  Neighbour: TPNeighbour;
begin
  Result := false;

  if Vertice <> nil then
    Neighbour := Vertice.Head
  else
    Neighbour := nil;

  while not Result and (Neighbour <> nil) do
  begin
    Result := Neighbour.Number = u;
    Neighbour := Neighbour.Next;
  end;

end;

procedure DestroyAdjList(var Head: TPNeighbour);
var
  Neighbour: TPNeighbour;
begin
  while Head <> nil do
  begin
    Neighbour := Head;
    Head := Head.Next;
    Dispose(Neighbour);
  end;
  Head := nil;
end;

procedure AddVertice;
var
  Vertice: TPVertice;
begin
  Inc(G.Order);

  // Инициализация новой вершины
  New(Vertice);
  with Vertice^ do
  begin
    Center := C;
    Number := G.Order;
    Head := nil;
    Next := nil;
    Deg := 0;
    Design := dgPassive;
  end;

  // Запись новой вершины
  if G.Head = nil then
    G.Head := Vertice
  else
    G.Tail.Next := Vertice;
  G.Tail := Vertice;

end;

procedure AddArc;
var
  Vertice, AdjVertice: TPVertice;
  Neighbour: TPNeighbour;
  isIncorrect: Boolean;
begin

  GetByNumber(G, v, Vertice);
  GetByNumber(G, u, AdjVertice);

  isIncorrect := AreAdjacent(G, Vertice, u) or AreAdjacent(G, AdjVertice, v);
  if not isIncorrect then
  begin

    Inc(Vertice.Deg);

    // Сохранение соседа в список смежности
    New(Neighbour);
    Neighbour.Number := u;
    Neighbour.Weight := w;
    Neighbour.isVisited := false;
    Neighbour.Next := Vertice.Head;
    Vertice.Head := Neighbour;

  end;
end;

procedure DeleteVertice;
var
  PrevVertice, Vertice: TPVertice;
  PrevAdjVertice, Neighbour: TPNeighbour;
begin
  Dec(G.Order);

  if v = G.Head.Number then
  begin
    // Удаление головной вершины
    Vertice := G.Head;
    G.Head := G.Head.Next;
  end
  else
  begin
    // Удаление не головной вершины
    GetByNumber(G, v - 1, PrevVertice);
    Vertice := PrevVertice.Next;
    PrevVertice.Next := Vertice.Next;
  end;

  // Освобождение памяти
  DestroyAdjList(Vertice.Head);
  Dispose(Vertice);

  // Цикл А1. Проход по вершинам графа
  Vertice := G.Head;
  while Vertice <> nil do
  begin

    // Уменьшение номеров вершин
    if Vertice.Number > v then
      Dec(Vertice.Number);

    // Изменение хвоста списка
    if Vertice.Next = nil then
      G.Tail := Vertice;

    // Цикл А2. Проход по соседям вершины
    PrevAdjVertice := nil;
    Neighbour := Vertice.Head;
    while Neighbour <> nil do
    begin

      // Удаление соседа текущей вершины
      if Neighbour.Number = v then
      begin
        if PrevAdjVertice = nil then
          Vertice.Head := Neighbour.Next
        else
          PrevAdjVertice.Next := Neighbour.Next;
        Dispose(Neighbour);
      end
      else if Neighbour.Number > v then
        Dec(Neighbour.Number); // Уменьшение номера соседа

      PrevAdjVertice := Neighbour;
      Neighbour := Neighbour.Next;
    end; // Конец А2
    Vertice := Vertice.Next;
  end; // Конец А1
end;

procedure DeleteArc;
var
  Vertice: TPVertice;
  Neighbour, PrevAdjVertice: TPNeighbour;
  isFound: Boolean;
begin

  // Получение начала дуги
  GetByNumber(G, v, Vertice);

  if not AreAdjacent(G, Vertice, u) then
    Exit;

  Dec(Vertice.Deg);

  // Получение первого соседа
  PrevAdjVertice := Vertice.Head;
  Neighbour := nil;

  // Поиск звена перед звеном с искомым соседом
  if (PrevAdjVertice = nil) or (PrevAdjVertice.Number = u) then
  begin
    if PrevAdjVertice <> nil then
      Vertice.Head := PrevAdjVertice.Next
    else
      Vertice.Head := nil;
  end
  else
  begin

    isFound := (PrevAdjVertice.Next.Number = u) or (PrevAdjVertice = nil);

    // Получение предыдущего соседа удаляемого
    while not isFound do
    begin
      PrevAdjVertice := PrevAdjVertice.Next;
      isFound := (PrevAdjVertice = nil) or (PrevAdjVertice.Next.Number = u);
    end;

    Neighbour := PrevAdjVertice.Next;
    PrevAdjVertice.Next := Neighbour.Next;
  end;

  // Удаление соседа
  if Neighbour <> nil then
  begin
    Dispose(Neighbour);
  end;

end;

procedure InitializeGraph;
begin
  G.Head := nil;
  G.Tail := nil;
  G.Order := 0;
  G.isPainted := false;
  G.R := 40;
end;

procedure DestroyGraph;
var
  Vertice: TPVertice;
begin

  // Цикл А1. Освобождение списка вершин
  while G.Head <> nil do
  begin
    Vertice := G.Head;

    // Цикл А2. Освобождение списка соседей вершины
    DestroyAdjList(Vertice.Head);

    G.Head := G.Head.Next;
    Dispose(Vertice);
  end; // Конец А1
end;

procedure GetByNumber;
begin
  Vertice := G.Head;
  while (Vertice <> nil) and (Vertice.Number <> v) do
    Vertice := Vertice.Next;
end;

function Centralize;
var
  Found: TPVertice;
begin

  Found := nil;
  Vertice := G.Head;

  // Цикл А1. Поиск последней вершины с близкими координатами
  while Vertice <> nil do
  begin
    if Distance(Vertice.Center, P) <= G.R then
      Found := Vertice;
    Vertice := Vertice.Next;
  end; // Конец А1

  Result := Found <> nil;
  Vertice := Found;

end;

procedure OpenGraph;
var
  Vertice: TPVertice;
  Neighbour: TPNeighbour;
  VerFile: File of TVertice;
  ArcFile: File of TNeighbour;
  v: Integer;
begin

  // Подготовка файлов
  System.Assign(VerFile, VerFileName);
  System.Assign(ArcFile, ArcFileName);
  Reset(VerFile);
  Reset(ArcFile);

  InitializeGraph(G);
  New(Vertice);
  New(Neighbour);
  // Цикл А1. Проход по файлу вершин
  while not Eof(VerFile) do
  begin

    // Чтение очередной вершины
    Read(VerFile, Vertice^);
    AddVertice(G, Vertice.Center);

    // Цикл А2. Частичный проход по файлу рёбер
    for v := 1 to Vertice.Deg do
    begin
      Read(ArcFile, Neighbour^);
      AddArc(G, Vertice.Number, Neighbour.Number, Neighbour.Weight);
    end; // Конец А2
  end; // Конец А1

  Dispose(Vertice);
  Dispose(Neighbour);

  // Закрытие файлов
  CloseFile(VerFile);
  CloseFile(ArcFile);

end;

procedure SaveGraph;
var
  Vertice: TPVertice;
  Neighbour: TPNeighbour;
  VerFile: File of TVertice;
  ArcFile: File of TNeighbour;
begin

  // Подготовка файлов
  System.Assign(VerFile, VerFileName);
  System.Assign(ArcFile, ArcFileName);
  Rewrite(VerFile);
  Rewrite(ArcFile);

  // Цикл А1. Проход по вершинам
  Vertice := G.Head;
  while Vertice <> nil do
  begin
    Write(VerFile, Vertice^);

    // Цикл А2. Проход по соседям
    Neighbour := Vertice.Head;
    while Neighbour <> nil do
    begin
      Write(ArcFile, Neighbour^);
      Neighbour := Neighbour.Next;
    end; // Конец А1
    Vertice := Vertice.Next;
  end; // Конец А2

  // Закрытие файлов
  CloseFile(VerFile);
  CloseFile(ArcFile);
end;

procedure ImportFromExcel;
const
  ExcelApp = 'Excel.Application';
var
  MyExcel: Variant;
  Sheet: OLEVariant;
  ClassID: TCLSID;
  Rez: HRESULT;
  i, j, Rows, Cols: Integer;
  Weights: OLEVariant;
  w, ww: Integer;
  ImageCenter, VerticeCenter: TPoint;
  PolygonRadius: Integer;
  Angle: Real;
  isIncorrect: Boolean;
begin
  if CLSIDFromProgID(PWideChar(WideString(ExcelApp)), ClassID) = S_OK then
  begin
    // Открытие приложения, книги и листа
    Coinitialize(nil);
    MyExcel := CreateOleObject(ExcelApp);
    MyExcel.WorkBooks.Open(FileName);
    Sheet := MyExcel.ActiveWorkBook.ActiveSheet;

    // Получение используемого диапазона ячеек
    Rows := Sheet.UsedRange.Rows.Count;
    Cols := Sheet.UsedRange.Columns.Count;
    if Rows <> Cols then
      raise Exception.Create('Матрица расстояний не была квадратной.');
    Weights := Sheet.UsedRange.Value;

    // Заполнение графа
    try
      Angle := 0;
      PolygonRadius := Min(Width, Height) div 2 - 40;
      ImageCenter.X := Width div 2;
      ImageCenter.Y := Height div 2;
      InitializeGraph(G);
      for i := 1 to Rows do
      begin
        VerticeCenter.X := ImageCenter.X + trunc(PolygonRadius * sin(Angle));
        VerticeCenter.Y := ImageCenter.Y - trunc(PolygonRadius * cos(Angle));
        AddVertice(G, VerticeCenter);
        for j := 1 to Cols do
        begin
          w := StrToInt(VarToStr(Weights[i, j]));
          ww := StrToInt(VarToStr(Weights[j, i]));

          // Проверка на недопустимые дуги
          isIncorrect := (i = j) and (w <> 0) or (w < 0) or (w > 0) and
            (ww <> 0);
          if isIncorrect then
            raise Exception.Create('Найдены недопустимые дуги.');

          // Добавление существующей дуги
          if w <> 0 then
            AddArc(G, i, j, w);
        end;
        Angle := Angle + 2 * pi / Rows;
      end;
    finally
      MyExcel.Quit;
      MyExcel := Unassigned;
      CoUninitialize;
    end;
  end;
end;

procedure ExportToSvg(var G: TGraph; FileName: String);
var
  Document: IXMLDocument;
  Root, Node: IXMLNode;
  Vertice: TPVertice;
  Neighbour: TPNeighbour;
  TempCanvas: TImage;
begin
  Document := TXMLDocument.Create(nil);
  Document.Active := True;

  Root := Document.AddChild('svg');
  Root.Attributes['xmlns'] := 'http://www.w3.org/2000/svg';

  Vertice := G.Head;
  while Vertice <> nil do
  begin
    Node := Root.AddChild('circle');
    Node.Attributes['xmlns'] := 'http://www.w3.org/2000/svg';
    Node.Attributes['cx'] := IntToStr(Vertice.Center.X);
    Node.Attributes['cy'] := IntToStr(Vertice.Center.Y);
    Node.Attributes['r'] := IntToStr(G.R);
    Node.Attributes['stroke'] := 'black';
    Node.Attributes['stroke-width'] := 3;
    Node.Attributes['fill'] := 'white';
    Node := Root.AddChild('text');
    Node.Attributes['xmlns'] := 'http://www.w3.org/2000/svg';
    Vertice := Vertice.Next;
  end;

  // Node := Root.AddChild('line');
  // Node.Attributes['xmlns'] := 'http://www.w3.org/2000/svg';
  // Node.Attributes['x1'] := '50';
  // Node.Attributes['y1'] := '50';
  // Node.Attributes['x2'] := '100';
  // Node.Attributes['y2'] := '100';
  // Node.Attributes['stroke'] := 'black';

  Document.SaveToFile(FileName);
end;

function Distance;
begin
  Result := Round(Sqrt(Sqr(p2.X - p1.X) + Sqr(p2.Y - p1.Y)));
end;

end.
