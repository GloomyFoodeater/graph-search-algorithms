unit Digraph;

interface

uses System.Types, DynStructures;

type

  // Тип списка смежности
  TPAdjList = TPList;

  // Тип вершины графа
  TPNode = ^TNode;

  TNode = record
    Center: TPoint;
    Number: Cardinal;
    Head: TPAdjList;
    Next: TPNode;
  end;

  // Тип простой граф
  TGraph = record
    Head: TPNode;
    Tail: TPNode;
    Order: Cardinal;
  end;

  { Функция нахождения вершины по номеру в списке }
function GetByNumber(const G: TGraph; v: Integer): TPNode;

{ Функция нахождения вершины по точке на холсте }
function GetByPoint(const G: TGraph; P: TPoint): TPNode;

{ Функция вычисления расстояния между двумя точками в пикселях }
function Distance(const p1, p2: TPoint): Integer;

{ Процедура добавления вершины в граф }
procedure AddNode(var G: TGraph; const C: TPoint);

{ Процедура добавления рёбер в граф }
procedure AddLink(var G: TGraph; u, v: Integer);

{ Процедура инициализации графа }
procedure InitializeGraph(var G: TGraph);

{ Процедура очищения графа }
procedure DisposeGraph(var G: TGraph);

{ Функция поиска в глубину }
function DFS(const G: TGraph; u, v: Integer): Boolean;

implementation

{ Функция вычисления расстояния между двумя точками в пикселях }
function Distance(const p1, p2: TPoint): Integer;
begin
  Result := Round(Sqrt(Sqr(p2.x - p1.x) + Sqr(p2.y - p1.y)));
end;

{ Функция нахождения вершины по номеру в списке }
function GetByNumber;
var
  i: Integer;
begin
  Result := G.Head;
  for i := 1 to v - 1 do
  begin
    Result := Result.Next;
  end;

end;

{ Функция нахождения вершины по точке на холсте }
function GetByPoint;
var
  Node: TPNode;
  Found: TPNode;
  isFound: Boolean;
  x, y: Integer;
begin
  Node := G.Head;
  isFound := False;
  Found := nil;

  while Node <> nil do
  begin
    isFound := Distance(Node.Center, P) <= 20;
    if isFound then
      Found := Node;
    Node := Node.Next;
  end;

  Result := Found;
end;

{ Процедура добавления вершины в граф }
procedure AddNode;
var
  t: TPNode;
begin
  Inc(G.Order);

  // Инициализация новой вершины
  New(t);
  with t^ do
  begin
    Center := C;
    Number := G.Order;
    Head := nil;
    Next := nil;
  end;

  // Инициализация указателя на новую вершину
  if G.Head = nil then
  begin
    G.Head := t;
    G.Tail := t;
  end
  else
  begin
    G.Tail.Next := t;
    G.Tail := t;
  end;

end;

{ Процедура добавления рёбер в граф }
procedure AddLink;
var
  Node: TPNode;
  a, b: TPList;
  isFound: Boolean;
begin

  // Получение начального соседа
  Node := GetByNumber(G, u);

  if Node.Head = nil then
  begin
    New(Node.Head);
    Node.Head.Elem := v;
    Node.Head.Next := nil;
  end
  else
  begin
    a := Node.Head;
    isFound := (a.Elem > v);
    if isFound then
    begin
      New(b);
      b.Elem := v;
      b.Next := a;
      Node.Head := b;
    end
    else
    begin

      isFound := (a.Next = nil) or (a.Elem > v);
      while not isFound do
      begin
        a := a.Next;
        isFound := (a.Next = nil) or (a.Elem > v);
      end;

    end;
  end;

end;

{ Процедура инициализации графа }
procedure InitializeGraph;
begin
  G.Head := nil;
  G.Tail := nil;
  G.Order := 0;
end;

{ Процедура очищения графа }
procedure DisposeGraph;
var
  pNode: TPNode;
  pAdjNode: TPAdjList;
begin

  // Цикл А1. Освобождение списка вершин
  while G.Head <> nil do
  begin
    pNode := G.Head;

    // Цикл А2. Освобождение списка соседей вершины
    while pNode.Head <> nil do
    begin
      pAdjNode := pNode.Head;
      pNode.Head := pNode.Head.Next;
      Dispose(pAdjNode);
    end; // Конец А2

    G.Head := G.Head.Next;
    Dispose(pNode);
  end; // Конец А1
end;

function DFS(const G: TGraph; u, v: Integer): Boolean;
var
  Node: TPNode;
  Neighbour: TPAdjList;
  Stack: TStack;
  isFound: Boolean;
  isVisited: Array of Boolean;
  i: Integer;
  w: Cardinal;
begin
  isFound := u = v;

  // Подготовка стека
  InitList(Stack);
  PushBack(Stack, u);

  // Инициализация массива меток
  SetLength(isVisited, G.Order);
  for i := Low(isVisited) to High(isVisited) do
    isVisited[i] := False;

  // Цикл по стеку, пока не найдена вершина
  while not(isEmpty(Stack) or isFound) do
  begin

    // Посещение вершины
    u := PopBack(Stack);
    isVisited[u] := true;

    // Цикл по соседям вершины
    Node := GetByNumber(G, u);
    Neighbour := Node.Head;
    while Neighbour <> nil do
    begin
      w := Neighbour.Elem;
      if not isVisited[w] then
        PushBack(Stack, w); // Добавление в стек непосещённых вершин
      Neighbour := Neighbour.Next;
    end;

  end;

  Result := isFound;
end;

end.
