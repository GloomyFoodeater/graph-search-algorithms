unit GraphSearch;

interface

{ Функция поиска в глубину }
function DFS(const G: TGraph; u, v: Cardinal): TStack;

{ Функция поиска в ширину }
function BFS(const G: TGraph; u, v: Cardinal): TStack;

{ Функция поиска алгоритмом Дейкстры }
function Dijkstra(const G: TGraph; u, v: Cardinal): TStack;

implementation

function RestorePath(const Parents: array of Cardinal; u, v: Integer): TStack;
begin

  InitializeStack(Result); // Инициализация стека

  // Цикл А1. Добавление очередного предка в пути
  while u <> v do
  begin
    Push(Result, v);
    v := Parents[v - 1];
  end; // Конец А1
  Push(Result, u);

end;

function DFS;
var
  Node: TPNode;
  Neighbour: TAdjList;
  Stack: TStack;
  isFound: Boolean;
  Parents: Array of Cardinal;
  isVisited: Array of Boolean;
  i: Integer;
  w, StartCopy: Cardinal;
begin

  // Инициализация стека
  InitializeStack(Stack);
  Push(Stack, u);

  // Инициализация массива меток
  SetLength(isVisited, G.Order);
  for i := Low(isVisited) to High(isVisited) do
    isVisited[i] := False;

  // Инциализация массива предков
  SetLength(Parents, G.Order);

  // Цикл А1. Извлечение элементов из стека до нахождения вершины
  StartCopy := u; // Сохранение начала пути
  isFound := u = v;
  while not(isEmpty(Stack) or isFound) do
  begin
    // Получение вершины
    u := Pop(Stack);
    if not isVisited[u - 1] then
    begin

      // Посещение вершины
      isVisited[u - 1] := true;
      isFound := u = v;

      // Цикл А2. Сохранение соседей в стек
      Node := GetByNumber(G, u);
      Neighbour := Node.Head;
      while not((Neighbour = nil) or isFound) do
      begin
        w := Neighbour.Elem;
        // Получение очередного соседа

        // Добавление в стек непосещённых вершин
        if not isVisited[w - 1] then
        begin
          Push(Stack, w); // Вставка вершины в стек
          Parents[w - 1] := u; // Сохранение пути
        end; // Конец if

        Neighbour := Neighbour.Next; // Переход к следующему соседу
      end; // Конец А2

    end; // Конец if

  end; // Конец А1

  DestroyList(Stack); // Очистка стека

  // Восстановление пути
  InitializeStack(Result);
  if isFound then
    Result := RestorePath(Parents, StartCopy, v);
end;

function BFS;
var
  Node: TPNode;
  Neighbour: TAdjList;
  Queue: TQueue;
  i: Cardinal;
  isVisited: Array of Boolean;
  Parents: Array of Cardinal;
  StartCopy: Cardinal;
  w: Cardinal;
  isFound: Boolean;
begin

  // Инициализация очереди
  InitializeQueue(Queue);
  Enqueue(Queue, u);

  // Инициализация массива меток
  SetLength(isVisited, G.Order);
  for i := Low(isVisited) to High(isVisited) do
    isVisited[i] := False;

  // Инициализация массива предков
  SetLength(Parents, G.Order);

  // Цикл А1. Извлечение из очереди вершин
  StartCopy := u;
  isFound := u = v;
  while not(isEmpty(Queue.Head) or isFound) do
  begin
    u := Dequeue(Queue);
    if not isVisited[u - 1] then
    begin

      // Посещение вершины
      isVisited[u - 1] := true;
      isFound := u = v;

      // Цикл А2. Вставка в очередь соседей вершины
      Node := GetByNumber(G, u);
      Neighbour := Node.Head;
      while not((Neighbour = nil) or isFound) do
      begin
        w := Neighbour.Elem;
        if not isVisited[w - 1] then
        begin
          Enqueue(Queue, w); // Запись в очередь
          Parents[w - 1] := u; // Сохранение пути
        end; // Конец if
        Neighbour := Neighbour.Next;
      end; // Конец А2

    end; // Конец if

  end; // Конец А1

  // Очистка очереди
  DestroyList(Queue.Head);

  // Восстановление пути
  InitializeStack(Result);
  if isFound then
    Result := RestorePath(Parents, StartCopy, v);

end;

function Dijkstra;
var
  Node: TPNode;
  Neighbour: TAdjList;
  isVisited: Array of Boolean;
  Marks: Array of Integer;
  i: Cardinal;
  w: Cardinal;
  Parents: Array of Cardinal;
  StartCopy: Cardinal;
  isFound: Boolean;
  d: Cardinal;
  AdjMatrix: TAdjMatrix;
begin

  ToAdjMatrix(G, AdjMatrix);

  // Инициализация меток
  SetLength(Marks, G.Order);
  for i := Low(Marks) to High(Marks) do
    Marks[i] := INFINITY;
  Marks[u - 1] := 0;

  // Инициализация массива меток
  SetLength(isVisited, G.Order);
  for i := Low(isVisited) to High(isVisited) do
    isVisited[i] := False;

  // Инициализация массива предков
  SetLength(Parents, G.Order);

  StartCopy := u;
  isFound := False;
  d := 0;

  while not(isFound or (d = INFINITY)) do
  begin
    MinDist(Marks, isVisited, u, d);
    isFound := u = v;
    isVisited[u - 1] := true;

    // TODO 3: Проход по циклу в случае, когда вершина найдена
    for w := 0 to G.Order - 1 do
    begin
      if not isVisited[w] and (Marks[w] > d + AdjMatrix[u - 1, w]) then
      begin
        Marks[w] := d + AdjMatrix[u - 1, w];
        Parents[w] := u;
      end;

    end;
  end;

  // Восстановление пути
  InitializeStack(Result);
  if isFound then
    Result := RestorePath(Parents, StartCopy, v);
end;

end.
