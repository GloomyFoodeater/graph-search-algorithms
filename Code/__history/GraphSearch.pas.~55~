unit GraphSearch;

interface

uses Digraph, DynStructures;

{ Процедура поиска в глубину }
procedure DFS(const Graph: TAdjMatrix; const Src, Dest: Integer;
  out Path: TStack);

{ Процедура поиска в ширину }
procedure BFS(const Graph: TAdjMatrix; const Src, Dest: Integer;
  out Path: TStack);

{ Процедура поиска алгоритмом Дейкстры }
procedure Dijkstra(const Graph: TAdjMatrix; const Src, Dest: Integer;
  out Path: TStack);

implementation

procedure MinDist(const Distances: array of Integer;
  const isVisited: Array of Boolean; out u, d: Integer);
var
  i: Integer;
begin

  d := INFINITY;

  for i := Low(Distances) to High(Distances) do
  begin
    if not isVisited[i] and (Distances[i] < d) then
    begin
      d := Distances[i];
      u := i + 1;
    end;
  end;
end;

procedure RestorePath(const Parents: array of Integer; const Src, Dest: Integer;
  out Path: TStack);
var
  v: Integer;
begin

  InitializeStack(Path); // Инициализация стека
  v := Dest;

  // Цикл А1. Добавление очередного предка в пути
  while (v <> Src) and (v <> 0) do
  begin
    Push(Path, v);
    v := Parents[v - 1];
  end; // Конец А1

  Push(Path, v);

  // Случай, если путь не был найден
  if v = 0 then
    DestroyList(Path);
end;

procedure DFS(const Graph: TAdjMatrix; const Src, Dest: Integer;
  out Path: TStack);
var
  v, u: Integer;
  Order: Integer;
  s: TStack;
  isVisited: Array of Boolean;
  Parents: Array of Integer;
begin

  Order := Length(Graph); // Получение порядка графа
  v := Src; // Сохранение старта

  // Подготовка стека
  InitializeStack(s);
  Push(s, v);

  // Подготовка меток
  SetLength(isVisited, Order);
  for u := 1 to Order do
    isVisited[u - 1] := False;
  isVisited[v - 1] := true;

  // Подготовка массива предков
  SetLength(Parents, Order);
  Parents[v - 1] := 0;

  // Цикл А1. Посещение вершин в стеке
  while not isEmpty(s) do
  begin

    // Получение вершины
    v := Pop(s);

    // Цикл А2. Добавление в стек всех соседей вершины
    for u := 1 to Order do
    begin
      if not isVisited[u - 1] and (Graph[v - 1, u - 1] <> INFINITY) then
      begin
        isVisited[u - 1] := true;
        Parents[u - 1] := v;
        Push(s, u);
      end; // Конец if

    end; // Конец А2

  end; // Конец А1

  // Восстановление пути
  RestorePath(Parents, Src, Dest, Path);
end;

procedure BFS(const Graph: TAdjMatrix; const Src, Dest: Integer;
  out Path: TStack);
var
  v, u: Integer;
  Order: Integer;
  q: TQueue;
  isVisited: Array of Boolean;
  Parents: Array of Integer;
begin

  Order := Length(Graph); // Получение порядка графа
  v := Src; // Сохранение старта

  // Подготовка стека
  InitializeQueue(q);
  Enqueue(q, v);

  // Подготовка меток
  SetLength(isVisited, Order);
  for u := 1 to Order do
    isVisited[u - 1] := False;
  isVisited[v - 1] := true;

  // Подготовка массива предков
  SetLength(Parents, Order);
  Parents[v - 1] := 0;

  // Цикл А1. Посещение всех вершин из очереди
  while not isEmpty(q.Head) do
  begin

    // Получение вершины
    v := Dequeue(q);

    // Цикл А2. Добавление в стек всех соседей вершины
    for u := 1 to Order do
    begin
      if not isVisited[u - 1] and (Graph[v - 1, u - 1] <> INFINITY) then
      begin
        isVisited[u - 1] := true;
        Parents[u - 1] := v;
        Enqueue(q, u);
      end; // Конец if

    end; // Конец А2

  end; // Конец А1

  // Восстановление пути
  RestorePath(Parents, Src, Dest, Path);

end;

procedure Dijkstra(const Graph: TAdjMatrix; const Src, Dest: Integer;
  out Path: TStack);
var
  v, u: Integer;
  Order: Integer;
  isVisited: Array of Boolean;
  Parents: Array of Integer;
  Marks: Array of Integer;
  isFound: Boolean;
  d: Integer;
begin

  Order := Length(Graph); // Получение порядка графа
  v := Src; // Сохранение старта

  // Подготовка массива расстояний
  SetLength(Marks, Order);
  for u := 1 to Order do
    Marks[u - 1] := INFINITY;
  Marks[v - 1] := 0;

  // Подготовка массива меток
  SetLength(isVisited, Order);
  for u := 1 to Order do
    isVisited[u - 1] := False;
  isVisited[v - 1] := true;

  // Подготовка массива предков
  SetLength(Parents, Order);
  Parents[v - 1] := 0;

  // Инициализация условий входа в цикл
  isFound := v = Dest;
  d := 0;

  // Цикл А1. Посещение вершин с минимальными расстояниями
  while not(isFound or (d = INFINITY)) do
  begin

    for u := 1 to Order do
    begin
      if not isVisited[u - 1] and (Marks[u - 1] > d + Graph[v - 1, u - 1]) then
      begin
        isVisited[u - 1] := true;
        Parents[u - 1] := v;
        Marks[u - 1] := d + Graph[v - 1, u - 1];
      end;
    end;

    MinDist(Marks, isVisited, v, d);
    isFound := v = Dest;

  end; // Конец А1

  // Восстановление пути
  RestorePath(Parents, Src, Dest, Path);

end;

end.
