unit DynStructures;

interface

type
  // Тип односвязный список с натуральными числами
  TPList = ^TItem;

  TItem = record
    Elem: Cardinal;
    Next: TPList;
  end;

  // Тип стек с натуральными числами
  TStack = TPList;

  // Тип очередь с натуральными числами
  TQueue = record
    Head: TPList;
    Tail: TPList;
  end;

  { Процедура инициализации стека }
procedure InitializeStack(var Stack: TStack);

{ Процедура инициализации очереди }
procedure InitializeQueue(var Queue: TQueue);

{ Процедура очищения стека }
procedure DestroyStack(var Stack: TStack);

{ Процедура очистки очереди }
procedure DestroyQueue(var Queue: TQueue);

{ Процедура вставки в стек }
procedure Push(var Stack: TStack; n: Cardinal);

{ Процедура вставки в очередь }
procedure Enqueue(var Queue: TQueue; n: Cardinal);

{ Функция извлечения из стека }
function Pop(var Stack: TStack): Cardinal;

{ Функция извлечения из очереди }
function Dequeue(var Queue: TQueue): Cardinal;

{ Функция проверки списка на пустоту }
function isEmpty(const Head: TPList): Boolean;

implementation

procedure InitializeStack;
begin
  Stack := nil;
end;

procedure InitializeQueue;
begin
  Queue.Head := nil;
  Queue.Tail := nil;
end;

procedure DestroyStack;
var
  t: TPList;
begin
  // Цикл А1. Освобождение списка
  while Stack <> nil do
  begin
    t := Stack;
    Stack := Stack.Next;
    Dispose(t);
  end; // Конец А1
  Stack := nil;
end;

procedure DestroyQueue;
var
  t: TPList;
begin
  // Цикл А1. Освобождение списка
  while Queue.Head <> nil do
  begin
    t := Queue.Head;
    Queue.Head := Queue.Head.Next;
    Dispose(t);
  end; // Конец А1
  Queue.Head := nil;
  Queue.Tail := nil;
end;

procedure Push;
var
  t: TPList; // Вставляемое звено списка
begin

  // Инициализация нового элемента
  New(t);
  t.Elem := n;
  t.Next := nil;

  // Перемещение вершины стека
  if not isEmpty(Stack) then
    t.Next := Stack;
  Stack := t;

end;

procedure Enqueue;
var
  t: TPList; // Вставляемое звено списка
begin

  // Инициализация нового элемента
  New(t);
  t.Elem := n;
  t.Next := nil;

  // Сохранение нового элемента
  if not isEmpty(Queue.Head) then
    Queue.Tail.Next := t
  else
    Queue.Head := t;

  // Перемещение хвоста
  Queue.Tail := t;
end;

function Pop;
var
  t: TPList; // Извлекаемое звено списка
begin

  if not isEmpty(Stack) then
  begin
    // Перемещение вершины стека
    t := Stack;
    Stack := Stack.Next;

    // Извлечение элемента с очисткой указателя
    Result := t.Elem;
    Dispose(t);
  end
  else
    Result := 0; // Ошибка при извлечении

end;

function Dequeue;
var
  t: TPList; // Извлекаемое звено списка
begin
  if not isEmpty(Queue.Head) then
  begin

    // Перемещение начала очереди
    with Queue do
    begin
      t := Head;
      Head := Head.Next;
    end;

    // Извлечение элемента с очисткой указателя
    Result := t.Elem;
    Dispose(t);
  end
  else
    Result := 0; // Ошибка при извлечении
end;

function isEmpty;
begin
  Result := Head = nil;
end;

end.
