unit Digraph;

interface

uses System.Types, System.SysUtils, Math, ComObj, Variants,
  ActiveX;

type

  // Тип стиля раскраски вершины
  TVerticeStyle = (stPassive, stActive, stVisited);

  // Тип списка смежности графа
  TPNeighbour = ^TNeighbour;

  TNeighbour = record
    Number: Integer;
    Weight: Integer;
    isVisited: Boolean;
    Next: TPNeighbour;
  end;

  // Тип вершины графа
  TPVertice = ^TVertice;

  TVertice = record
    Number: Integer;
    Center: TPoint;
    OutDeg: Integer;
    Style: TVerticeStyle;
    Head: TPNeighbour;
    Next: TPVertice;
  end;

  // Тип ориентированного графа
  TGraph = record
    Head: TPVertice;
    Tail: TPVertice;
    Order: Integer;
    isPainted: Boolean;
    R: Integer;
  end;

  // Подпрограмма инициализации графа
procedure InitializeGraph(var Graph: TGraph);

// Подпрограмма удаления графа
procedure DestroyGraph(var Graph: TGraph);

// Подпрограмма добавления вершины в граф
procedure AddVertice(var Graph: TGraph; C: TPoint);

// Подпрограмма добавления дуги в граф
procedure AddArc(var Graph: TGraph; v, u, w: Integer);

// Подпрограмма удаления вершины из графа
procedure DeleteVertice(var Graph: TGraph; v: Integer);

// Подпрограмма удаления дуги из графа
procedure DeleteArc(var Graph: TGraph; v, u: Integer);

// Подпрограмма получения вершины по её номеру
function GetByNumber(const Graph: TGraph; v: Integer): TPVertice;

// Подпрограмма получения вершины по точке на холсте
function GetByPoint(const Graph: TGraph; P: TPoint): TPVertice;

// Подпрограмма открытия графа из типизированных файлов
procedure OpenGraph(var Graph: TGraph; VerFileName, ArcFileName: String);

// Подпрограмма сохранения графа в типизированные файлы
procedure SaveGraph(const Graph: TGraph; VerFileName, ArcFileName: String);

// Подпрограмма экспорта графа из экселя
procedure ImportGraph(var Graph: TGraph; ExcelFileName: String);

implementation

procedure DestroyAdjList(var Head: TPNeighbour);
var
  Neighbour: TPNeighbour;
  // Neighbour - Ссылка на удаляемого соседа

begin

  // Цикл А1. Проход по списку смежности
  while Head <> nil do
  begin
    Neighbour := Head;
    Head := Head.Next;
    Dispose(Neighbour);
  end; // Конец А1
end;

procedure InitializeGraph(var Graph: TGraph);
begin
  with Graph do
  begin
    Head := nil;
    Tail := nil;
    Order := 0;
    isPainted := false;
    R := 40;
  end;
end;

procedure DestroyGraph(var Graph: TGraph);
var
  Vertice: TPVertice;
  // Vertice - Ссылка на удаляемую вершину

begin

  // Цикл А1. Проход по списку вершин
  while Graph.Head <> nil do
  begin
    Vertice := Graph.Head;
    DestroyAdjList(Vertice.Head);
    Graph.Head := Graph.Head.Next;
    Dispose(Vertice);
  end; // Конец А1
end;

// Подпрограмма проверки смежности вершин
function IsNeighbour(const Graph: TGraph; Vertice: TPVertice;
  u: Integer): Boolean;
var
  Neighbour: TPNeighbour;
  // Neighbour - Ссылка на сосед с номером u

begin
  Result := false;

  // AddArc может передать nil во время чтения/импорта из файла
  if Vertice <> nil then
    Neighbour := Vertice.Head
  else
    Neighbour := nil;

  // Цикл А1. Проход по списку смежности
  while not Result and (Neighbour <> nil) do
  begin
    Result := Neighbour.Number = u;
    Neighbour := Neighbour.Next;
  end; // Конец А1

end;

procedure AddVertice(var Graph: TGraph; C: TPoint);
var
  Vertice: TPVertice;
  // Vertice - Ссылка на добавляемую вершину

begin
  Inc(Graph.Order); // Увеличение порядка

  // Инициализация новой вершины
  New(Vertice);
  with Vertice^ do
  begin
    Center := C;
    Number := Graph.Order;
    Head := nil;
    Next := nil;
    OutDeg := 0;
    Style := stPassive;
  end;

  // Запись новой вершины
  if Graph.Head = nil then
    Graph.Head := Vertice
  else
    Graph.Tail.Next := Vertice;
  Graph.Tail := Vertice;

end;

procedure AddArc(var Graph: TGraph; v, u, w: Integer);
var
  Vertice, AdjVertice: TPVertice;
  Neighbour: TPNeighbour;
  isIncorrect: Boolean;
  // Vertice - Ссылка на вершину v
  // AdjVertice - Ссылка на вершину u
  // Neighbour - Ссылка на добавляемого соседа
  // isIncorrect - Флаг об отсутствии кратных дуг и петель

begin

  // Получение ссылок на вершины v и u
  Vertice := GetByNumber(Graph, v);
  AdjVertice := GetByNumber(Graph, u);

  // Проверка корректности графа в случае добавления дуги
  isIncorrect := (v = u) or IsNeighbour(Graph, Vertice, u) or
    IsNeighbour(Graph, AdjVertice, v);
  if not isIncorrect then
  begin

    Inc(Vertice.OutDeg);

    // Добавление соседа в список смежности
    New(Neighbour);
    with Neighbour^ do
    begin
      Number := u;
      Weight := w;
      isVisited := false;
      Next := Vertice.Head;
    end;
    Vertice.Head := Neighbour;
  end;
end;

procedure DeleteVertice(var Graph: TGraph; v: Integer);
var
  Vertice, PrVertice: TPVertice;
  Neighbour, PrNeighbour: TPNeighbour;
  // Vertice - Ссылка на текущего вершину
  // PrVertice - Ссылка на вершину перед Vertice
  // Neighbour - Ссылка на текущего соседа
  // PrNeighbour - Ссылка на соседа перед Neighbour

begin

  // Удаление вершины
  if v <> Graph.Head.Number then
  begin

    PrVertice := GetByNumber(Graph, v - 1);
    if (PrVertice = nil) or (PrVertice.Next = nil) then
      Exit; // Введена несуществующая вершина
    Vertice := PrVertice.Next;
    PrVertice.Next := Vertice.Next;
  end
  else
  begin

    // Удаляется голова списка
    Vertice := Graph.Head;
    Graph.Head := Vertice.Next;
  end;

  Dec(Graph.Order);

  // Освобождение памяти
  DestroyAdjList(Vertice.Head);
  Dispose(Vertice);

  // Цикл А1. Проход по вершинам графа
  Vertice := Graph.Head;
  while Vertice <> nil do
  begin

    // Уменьшение номеров вершин
    if Vertice.Number > v then
      Dec(Vertice.Number);

    // Изменение хвоста списка вершин
    if Vertice.Next = nil then
      Graph.Tail := Vertice;

    // Цикл А2. Проход по соседям вершины
    PrNeighbour := nil;
    Neighbour := Vertice.Head;
    while Neighbour <> nil do
    begin

      // Удаление соседа текущей вершины
      if Neighbour.Number = v then
      begin
        if PrNeighbour = nil then
          Vertice.Head := Neighbour.Next
        else
          PrNeighbour.Next := Neighbour.Next;
        Dispose(Neighbour);
      end
      else if Neighbour.Number > v then
        Dec(Neighbour.Number); // Уменьшение номера соседа

      // Переход к следующему соседу
      PrNeighbour := Neighbour;
      Neighbour := Neighbour.Next;
    end; // Конец А2

    // Переход к следующей вершине
    Vertice := Vertice.Next;
  end; // Конец А1
end;

procedure DeleteArc(var Graph: TGraph; v, u: Integer);
var
  Vertice: TPVertice;
  Neighbour, PrNeighbour: TPNeighbour;
  // Vertice - Ссылка на вершину-начало дуги
  // Neighbour - Ссылка на искомый для удаления сосед
  // PrNeighbour - Ссылка на соседа перед Neighbour

begin

  // Получение начала дуги
  Vertice := GetByNumber(Graph, v);

  if IsNeighbour(Graph, Vertice, u) then
  begin

    // Цикл А1. Проход по списку смежности
    PrNeighbour := nil;
    Neighbour := Vertice.Head;
    while Neighbour <> nil do
    begin

      // Сравнение номеров текущего и удаляемого соседа
      if u = Neighbour.Number then
      begin
        Dec(Vertice.OutDeg);

        // Удаление соседа из списка смежности
        if u = Vertice.Head.Number then
          Vertice.Head := Neighbour.Next
        else
          PrNeighbour.Next := Neighbour.Next;
        Dispose(Neighbour);
        Neighbour := nil;
      end // Конец if
      else
      begin

        // Переход к следующему соседу
        PrNeighbour := Neighbour;
        Neighbour := Neighbour.Next;
      end; // Конец else
    end; // Конец А1
  end; // Конец if

end;

function GetByNumber(const Graph: TGraph; v: Integer): TPVertice;
begin

  // Цикл А1. Проход по списку вершин
  Result := Graph.Head;
  while (Result <> nil) and (Result.Number <> v) do
    Result := Result.Next;
end;

function GetByPoint(const Graph: TGraph; P: TPoint): TPVertice;
var
  Vertice: TPVertice;
  // Vertice - Ссылка на текущую вершину графа

begin

  // Цикл А1. Поиск последней вершины с близкими координатами
  Result := nil;
  Vertice := Graph.Head;
  while Vertice <> nil do
  begin

    // Проверка принадлежности окружности радиуса Graph.R
    if P.Distance(Vertice.Center) <= Graph.R then
      Result := Vertice;
    Vertice := Vertice.Next;
  end; // Конец А1
end;

procedure OpenGraph(var Graph: TGraph; VerFileName, ArcFileName: String);
var
  VerFile: File of TVertice;
  ArcFile: File of TNeighbour;
  Vertice: TPVertice;
  Neighbour: TPNeighbour;
  v: Integer;
  // VerFile - Типизированный файл вершин
  // ArcFile - Типизированный файл соседей
  // Vertice - Ссылка на текущую вершину
  // Neighbour - Ссылка на текущего соседа
  // v - Параметр цикла по соседям

begin

  // Подготовка файлов
  Assign(VerFile, VerFileName);
  Assign(ArcFile, ArcFileName);
  Reset(VerFile);
  Reset(ArcFile);

  // Инициализация графа, указателя на вершину и соседа
  InitializeGraph(Graph);
  New(Vertice);
  New(Neighbour);

  // Цикл А1. Проход по файлу вершин
  while not Eof(VerFile) do
  begin

    // Чтение очередной вершины
    Read(VerFile, Vertice^);
    AddVertice(Graph, Vertice.Center);

    // Цикл А2. Частичный проход по файлу соседей
    for v := 1 to Vertice.OutDeg do
    begin

      // Чтение очередного соседа
      Read(ArcFile, Neighbour^);
      AddArc(Graph, Vertice.Number, Neighbour.Number, Neighbour.Weight);
    end; // Конец А2
  end; // Конец А1

  // Освобождение памяти
  Dispose(Vertice);
  Dispose(Neighbour);

  // Закрытие файлов
  CloseFile(VerFile);
  CloseFile(ArcFile);
end;

procedure SaveGraph(const Graph: TGraph; VerFileName, ArcFileName: String);
var
  VerFile: File of TVertice;
  ArcFile: File of TNeighbour;
  Vertice: TPVertice;
  Neighbour: TPNeighbour;
  // VerFile - Типизированный файл вершин
  // ArcFile - Типизированный файл соседей
  // Vertice - Ссылка на текущую вершину
  // Neighbour - Ссылка на текущего соседа

begin

  // Подготовка файлов
  Assign(VerFile, VerFileName);
  Assign(ArcFile, ArcFileName);
  Rewrite(VerFile);
  Rewrite(ArcFile);

  // Цикл А1. Проход по вершинам
  Vertice := Graph.Head;
  while Vertice <> nil do
  begin
    Write(VerFile, Vertice^);

    // Цикл А2. Проход по соседям
    Neighbour := Vertice.Head;
    while Neighbour <> nil do
    begin
      Write(ArcFile, Neighbour^);
      Neighbour := Neighbour.Next;
    end; // Конец А1
    Vertice := Vertice.Next;
  end; // Конец А2

  // Закрытие файлов
  CloseFile(VerFile);
  CloseFile(ArcFile);
end;

procedure ImportGraph(var Graph: TGraph; ExcelFileName: String);
const
  ExcelApp = 'Excel.Application';
  VerticeCenter: TPoint = (x: 0; y: 0);
var
  MyExcel: Variant;
  Sheet, Weights: OLEVariant;
  CLSID: TCLSID;
  i, j, Rows, Cols: Integer;
  w, ww: Integer;
  isIncorrect: Boolean;
  // MyExcel - Объект Excel
  // Sheet - Объект активного листа книги
  // Weights - Объект диапазона ячеек
  // CLSID  - Идентификатор, определяющий тип COM-объекта
  // i, j - Параметры циклов по строкам и столбцам диапазона
  // Rows, Cols - Количество строк и столбцов диапазона
  // w, ww - Симметричные в диапазоне ячейки
  // VerticeCenter - Центр очередной вершины на холсте
  // isIncorrect - Флаг о существовании недопустимых дуг

begin

  // Проверка наличия Excel на компьютере
  if CLSIDFromProgID(PWideChar(WideString(ExcelApp)), CLSID) = S_OK then
  begin

    // Открытие приложения, книги и листа
    CoInitialize(nil);
    MyExcel := CreateOleObject(ExcelApp);
    MyExcel.WorkBooks.Open(ExcelFileName);
    Sheet := MyExcel.ActiveWorkBook.ActiveSheet;

    // Получение используемого диапазона ячеек
    Rows := Sheet.UsedRange.Rows.Count;
    Cols := Sheet.UsedRange.Columns.Count;
    if Rows <> Cols then
      raise Exception.Create('Матрица расстояний не была квадратной.');
    Weights := Sheet.UsedRange.Value;

    // Заполнение графа
    try

      // Цикл А1. Проход по строкам диапазона
      InitializeGraph(Graph); // Инициализация графа
      for i := 1 to Rows do
      begin

        // Добавление вершины
        AddVertice(Graph, VerticeCenter);

        // Цикл А2. Проход по столбцам диапазона
        for j := 1 to Cols do
        begin

          // Получение весов в симметричных ячейках
          w := StrToInt(VarToStr(Weights[i, j]));
          ww := StrToInt(VarToStr(Weights[j, i]));

          // Проверка на недопустимые дуги
          isIncorrect := (i = j) and (w <> 0) or (w < 0) or (w > 0) and
            (ww <> 0);
          if isIncorrect then
            raise Exception.Create('Найдены недопустимые дуги.');

          // Добавление существующей дуги
          if w <> 0 then
            AddArc(Graph, i, j, w);
        end; // Конец A2
      end; // Конец A1
    finally

      // Выход из Excel
      MyExcel.Quit;
      MyExcel := Unassigned;
      CoUninitialize;
    end; // Конец if
  end;
end;

end.
