unit MainUnit;

interface

uses
  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
  Dialogs, ExtCtrls, StdCtrls, Buttons, Menus, GraphSearch, Digraph,
  DynStructures, GraphDrawing;

type
  TfrmGraphEditor = class(TForm)
    plFunctionsContainer: TPanel;
    AddNodeBtn: TSpeedButton;
    AddLinkBtn: TSpeedButton;
    DeleteNodeBtn: TSpeedButton;
    DeleteLinkBtn: TSpeedButton;
    DFSBtn: TSpeedButton;
    BFSbtn: TSpeedButton;
    DijkstraBtn: TSpeedButton;
    imGraphCanvas: TImage;
    mmMain: TMainMenu;
    nFile: TMenuItem;
    nEdit: TMenuItem;
    nHelp: TMenuItem;
    nOpen: TMenuItem;
    nSave: TMenuItem;
    nExit: TMenuItem;
    nClear: TMenuItem;
    nAbout: TMenuItem;
    N1: TMenuItem;
    procedure frmGraphEditorCreate(Sender: TObject);
    procedure frmGraphEditorClose(Sender: TObject; var Action: TCloseAction);
    procedure SetClickState(Sender: TObject);
    procedure imGraphCanvasClick(Sender: TObject);
    procedure SaveGraph(Sender: TObject);
    procedure OpenGraph(Sender: TObject);
    procedure nExitClick(Sender: TObject);
  end;

  // Тип режима работы с графом
  TClickState = (stAddVertice, stAddArc, stDeleteVertice, stDeleteArc, stDFS,
    stBFS, stDijkstra, stNone);

var
  frmGraphEditor: TfrmGraphEditor;
  State: TClickState; // Переменная состояния для работы с графом
  G: TGraph; // Граф для редактирования
  StartVertice: TPVertice = nil; // Указатель на запомненную вершину
  isToRedraw: Boolean = false; // Флаг о том, что необходимо перериосвать граф

const
  R = 40; // Радиус вершины графа

implementation

{$R *.dfm}

// Вспомогательная функция для вызова процедур поиска
function StartSearch(const G: TGraph; State: TClickState;
  v, u: Integer): Boolean;
var
  Weights: TWeights; // Матрица весов
  Path: TStack; // Пройденный путь
  Vertice: TPVertice; // Указатель на вершину
begin
  ToWeightMatrix(G, Weights); // Преобразование в матрицу расстояний

  // Выбор алгоритма поиска
  case State of
    stDFS:
      DFS(Weights, v, u, Path);
    stBFS:
      BFS(Weights, v, u, Path);
    stDijkstra:
      Dijkstra(Weights, v, u, Path);
  end;

  // Результат о достижимости конечной вершины
  Result := not isEmpty(Path);

  // Цикл А1. Перекраска вершин пути
  while not isEmpty(Path) do
  begin
    v := Pop(Path);
    GetByNumber(G, v, Vertice);
    Vertice.Design := dgVisited;
  end; // Конец А1

end;

// Метод создания формы
procedure TfrmGraphEditor.frmGraphEditorCreate(Sender: TObject);
begin
  State := stNone; // Инициализация режима работы

  // Инициализация графических настроек
  with frmGraphEditor.imGraphCanvas.Canvas do
  begin
    Pen.Width := 3;
    Font.Size := 15;
    Font.Style := [fsBold];
  end;
end;

// Метод закрытия формы
procedure TfrmGraphEditor.frmGraphEditorClose(Sender: TObject;
  var Action: TCloseAction);
begin
  DestroyGraph(G); // Освобождение занятой памяти
end;

// Метод получения переменной состояния через кнопки на панели
procedure TfrmGraphEditor.SetClickState(Sender: TObject);
var
  i: Integer; // Номер кнопки на панели
  Child: TControl; // Список контролов на панели
begin
  // Перерисовка в случае необходимости
  isToRedraw := isToRedraw or (StartVertice <> nil);
  if isToRedraw then
    RedrawGraph(imGraphCanvas, R, G, true);

  // Инициализация режима работы и начальной вершины
  StartVertice := nil;
  State := stNone;

  // Цикл А1. Перебор контролов панели
  for i := 0 to plFunctionsContainer.ControlCount - 1 do
  begin
    Child := plFunctionsContainer.Controls[i];
    if (Child as TSpeedButton).Down then
      State := TClickState(i);
  end; // Конец А1
end;

// Основной метод для редактирования графа
procedure TfrmGraphEditor.imGraphCanvasClick(Sender: TObject);
var
  Pos: TPoint; // Позиция курсора мыши
  Vertice: TPVertice; // Указатель на вершину
  isFound: Boolean; // Флаг о достижимости вершины при поиске
begin

  // Перерисовка графа
  if isToRedraw then
  begin
    RedrawGraph(imGraphCanvas, R, G, true);
    isToRedraw := false;
  end;

  // Перебор переменной состояния
  Pos := ScreenToClient(Mouse.CursorPos);
  case State of
    stAddVertice: // Добавление вершины
      AddVertice(G, Pos);
    stDeleteVertice: // Удаление вершины
      begin
        Centralize(G, Pos, R, Vertice);
        if Vertice <> nil then
          DeleteVertice(G, Vertice.Number);
      end;
    stAddArc, stDeleteArc, stDFS, stBFS, stDijkstra: // Действия по 2-м вершинам
      begin
        if StartVertice = nil then
        begin

          // Получение начальной вершины
          Centralize(G, Pos, R, StartVertice);
          if StartVertice = nil then
            Exit;
          StartVertice.Design := dgActive;

        end // Конец if
        else
        begin
          Centralize(G, Pos, R, Vertice);
          if Vertice = nil then
            Exit;

          // Перебор переменной состояния
          case State of
            stAddArc: // Добавление ребра
              begin
                StartVertice.Design := dgPassive;
                if not AreAdjacent(G, Vertice.Number, StartVertice.Number) then
                  AddArc(G, StartVertice.Number, Vertice.Number)
                else
              end;
            stDeleteArc: // Удаление ребра
              begin
                StartVertice.Design := dgPassive;
                if AreAdjacent(G, StartVertice.Number, Vertice.Number) then
                  DeleteArc(G, StartVertice.Number, Vertice.Number);
              end;
            stDFS, stBFS, stDijkstra: // Алгоритмы поиска
              begin
                isFound := StartSearch(G, State, StartVertice.Number,
                  Vertice.Number);
                if not isFound then
                begin
                  Vertice.Design := dgPassive;
                  ShowMessage('Путь не найден.');
                end;
                isToRedraw := true; // Флаг о необходимости перерисовки
              end;
          end;
          StartVertice := nil; // Сброс начальной вершины после обработки обеих
        end;

      end;
  end; // Конец case

  if State <> stNone then
    RedrawGraph(imGraphCanvas, R, G, false);
end;

procedure TfrmGraphEditor.nExitClick(Sender: TObject);
begin
  Close;
end;

procedure TfrmGraphEditor.OpenGraph(Sender: TObject);
var
  fVertices: File of TVertice;
  fArcs: File of TItem;
  Vertice: TPVertice;
  AdjVertice: TPAdjVertice;
  i: Integer;
  j: Integer;
begin
  DestroyGraph(G);
  InitializeGraph(G);

  System.Assign(fVertices, 'Graph.ver');
  System.Assign(fArcs, 'Graph.arc');

  Reset(fVertices);
  Reset(fArcs);

  i := 0;
  while not Eof(fVertices) do
  begin

    // Чтение вершины из файла вершин
    if i = 0 then
    begin

      // Чтение головы списка вершин
      New(Vertice);
      Read(fVertices, Vertice^);
      G.Head := Vertice;
    end
    else
    begin

      // Чтение не головной вершины
      New(Vertice.Next);
      Vertice := Vertice.Next;
      Read(fVertices, Vertice^);
    end;

    if Vertice.Deg <> 0 then
    begin
      for j := 1 to Vertice.Deg do
      begin
        if j = 1 then
        begin
          New(AdjVertice);
          Read(fArcs, AdjVertice^);
          Vertice.Head := AdjVertice;
        end
        else
        begin
          New(AdjVertice.Next);
          AdjVertice := AdjVertice.Next;
          Read(fArcs, AdjVertice^);
        end;

      end;
    end;

    Inc(i);
  end;

  G.Order := i;
  RedrawGraph(imGraphCanvas, R, G, true);
end;

procedure TfrmGraphEditor.SaveGraph(Sender: TObject);
var
  fVertices: File of TVertice;
  fArcs: File of TItem;
  Vertice: TPVertice;
  AdjVertice: TPAdjVertice;
begin
  isToRedraw := isToRedraw or (StartVertice <> nil);
  if isToRedraw then
  begin
    RedrawGraph(imGraphCanvas, R, G, true);
    isToRedraw := false;
  end;
  System.Assign(fVertices, 'Graph.ver');
  System.Assign(fArcs, 'Graph.arc');

  Rewrite(fVertices);
  Rewrite(fArcs);

  Vertice := G.Head;
  while Vertice <> nil do
  begin
    Write(fVertices, Vertice^);
    AdjVertice := Vertice.Head;
    while AdjVertice <> nil do
    begin
      Write(fArcs, AdjVertice^);
      AdjVertice := AdjVertice.Next;
    end;
    Vertice := Vertice.Next;
  end;
end;

end.
