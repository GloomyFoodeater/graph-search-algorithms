unit Digraph;

interface

uses System.Types, DynStructures, System.SysUtils;

const
  INFINITY = MaxInt;

type

  // Тип списка смежности
  TAdjList = TPList;

  // Тип вершины графа
  TPNode = ^TNode;

  TNode = record
    Center: TPoint;
    Number: Cardinal;
    Head: TAdjList;
    Next: TPNode;
  end;

  // Тип простой граф
  TGraph = record
    Head: TPNode;
    Tail: TPNode;
    Order: Cardinal;
  end;

  TAdjMatrix = array of array of Integer;

  { Функция нахождения вершины и её координаты по точке на холсте }
procedure Centralize(const G: TGraph; var P: TPoint; out u: Cardinal);

{ Функция получения центра вершины }
function GetCenter(const G: TGraph; u: Cardinal): TPoint;

{ Функция вычисления расстояния между двумя точками в пикселях }
function Distance(const p1, p2: TPoint): Integer;

{ Процедура добавления вершины в граф }
procedure AddNode(var G: TGraph; const C: TPoint);

{ Процедура добавления рёбер в граф }
procedure AddLink(var G: TGraph; u, v: Cardinal);

{ Процедура удаления вершины из графа }
procedure DeleteNode(var G: TGraph; u: Cardinal);

{ Процедура удаления ребра из графа }
procedure DeleteLink(var G: TGraph; u, v: Cardinal);

{ Процедура инициализации графа }
procedure InitializeGraph(var G: TGraph);

{ Процедура очищения графа }
procedure DestroyGraph(var G: TGraph);

{ Функция поиска в глубину }
function DFS(const G: TGraph; u, v: Cardinal): TStack;

{ Функция поиска в ширину }
function BFS(const G: TGraph; u, v: Cardinal): TStack;

{ Функция поиска алгоритмом Дейкстры }
function Dijkstra(const G: TGraph; u, v: Cardinal): TStack;

{ Процедура преобразования графа в матрицу смежности }
procedure ToAdjMatrix(const G: TGraph; var Matrix: TAdjMatrix);

implementation

procedure MinDist(const Distances: array of Integer;
  const isVisited: Array of Boolean; out u, d: Cardinal);
var
  i: Integer;
begin

  d := INFINITY;

  for i := Low(Distances) to High(Distances) do
  begin
    if not isVisited[i] and (Distances[i] < d) then
    begin
      d := Distances[i];
      u := i + 1;
    end;
  end;
end;

function Distance(const p1, p2: TPoint): Integer;
begin
  Result := Round(Sqrt(Sqr(p2.x - p1.x) + Sqr(p2.y - p1.y)));
end;

{ Функция нахождения вершины по номеру в списке }
function GetByNumber(const G: TGraph; u: Integer): TPNode;
begin
  Result := G.Head;

  // Цикл А1. Поиск вершины с данным номером
  while (Result <> nil) and (Result.Number <> u) do
  begin
    Result := Result.Next;
  end; // Конец А1

end;

procedure Centralize;
var
  Node: TPNode;
  Found: TPNode;
  isFound: Boolean;
begin
  Node := G.Head;
  isFound := False;
  Found := nil;

  // Цикл А1. Поиск последней вершины с близкими координатами
  while Node <> nil do
  begin
    isFound := Distance(Node.Center, P) <= 20;
    if isFound then
      Found := Node;
    Node := Node.Next;
  end; // Конец А1

  // Возврат найденной вершины
  if Found <> nil then
  begin
    u := Found.Number;
    P := Found.Center;
  end
  else
    u := 0; // Вершина не была найдена
end;

function GetCenter;
var
  Node: TPNode;
begin
  Node := GetByNumber(G, u);
  if Node <> nil then
    Result := Node.Center;
end;

procedure AddNode;
var
  Node: TPNode;
begin
  Inc(G.Order);

  // Инициализация новой вершины
  New(Node);
  with Node^ do
  begin
    Center := C;
    Number := G.Order;
    Head := nil;
    Next := nil;
  end;

  // Инициализация указателя на новую вершину
  if G.Head = nil then
    G.Head := Node
  else
    G.Tail.Next := Node;

  // Перезапись хвоста
  G.Tail := Node;

end;

procedure AddLink;
var
  Node: TPNode;
  Prev, Curr: TPList;
  isFound: Boolean;
begin

  // Получение вершины
  Node := GetByNumber(G, u);

  // Инициализация нового соседа
  New(Curr);
  Curr.Elem := v;

  // Получение начального соседа
  Prev := Node.Head;

  // Список смежности был пуст или голова была больше нового соседа
  if (Prev = nil) or (Prev.Elem > v) then
  begin
    Curr.Next := Prev;
    Node.Head := Curr;
  end
  else
  begin

    // Цикл А1. Поиск места вставки (предыдущего соседа)
    isFound := (Prev.Next = nil) or (Prev.Next.Elem > v);
    while not isFound do
    begin
      Prev := Prev.Next;
      isFound := (Prev.Next = nil) or (Prev.Next.Elem > v);
    end;

    // Вставка нового соседа
    Curr.Next := Prev.Next;
    Prev.Next := Curr;

  end; // Конец if

end;

procedure DeleteNode;
var
  PrNode, Node: TPNode;
  PrNeighbour, Neighbour: TPList;

begin

  // Проверка корректности полученных данных
  if (u < 1) or (u > G.Order) then
    Exit;
  Dec(G.Order);

  // Цикл А1. Проход по вершинам
  PrNode := nil;
  Node := G.Head;
  while Node <> nil do
  begin

    // Проверка номера вершины
    if Node.Number = u then
    begin

      // Переназначение предыдущего указателя
      if PrNode = nil then
        G.Head := Node.Next
      else
        PrNode.Next := Node.Next;

      // Освобождение списка смежности
      DestroyList(Node.Head);
      Dispose(Node);
    end // Конец if
    else
    begin

      // Уменьшение всех вершин, больших удаляемой на 1
      if Node.Number > u then
        Dec(Node.Number);

      // Цикл А2. Проход по соседям вершины
      PrNeighbour := nil;
      Neighbour := Node.Head;
      while Neighbour <> nil do
      begin

        // Проверка номера соседа
        if Neighbour.Elem = u then
        begin

          // Переназначение предыдущего указателя
          if PrNeighbour = nil then
            Node.Head := Neighbour.Next
          else
            PrNeighbour.Next := Neighbour.Next;

          // Освобождение памяти звена списка
          Dispose(Neighbour);
        end // Конец if
        else if Neighbour.Elem > u then
          Dec(Neighbour.Elem);

        // Переход к следующему соседу
        PrNeighbour := Neighbour;
        Neighbour := Neighbour.Next;

      end; // Конец А2

    end; // Конец else

    // Переход к следующей вершине
    if Node.Next <> nil then
      PrNode := Node;
    Node := Node.Next;
  end; // Конец А1

  // Переназначение хвоста списка
  G.Tail := PrNode;
end;

procedure DeleteLink;
var
  Node: TPNode;
  Neighbour: TPList;
  DelNeighbour: TPList;
  isFound: Boolean;
begin

  // Получение начала дуги
  Node := GetByNumber(G, u);

  // Получение первого соседа
  Neighbour := Node.Head;

  // Поиск звена перед звеном с искомым соседом
  if (Neighbour = nil) or (Neighbour.Elem = v) then
  begin
    DelNeighbour := Neighbour;
    if DelNeighbour <> nil then
      Node.Head := DelNeighbour.Next
    else
      Node.Head := nil;
  end
  else
  begin

    isFound := (Neighbour.Next.Elem = v) or (Neighbour = nil);

    // Получение предыдущего соседа удаляемого
    while not isFound do
    begin
      Neighbour := Neighbour.Next;
      isFound := (Neighbour = nil) or (Neighbour.Next.Elem = v);
    end;

    DelNeighbour := Neighbour.Next;
    Neighbour.Next := DelNeighbour.Next;
  end;

  // Удаление соседа
  if not(DelNeighbour = nil) then
  begin
    Dispose(DelNeighbour);
  end;

end;

procedure InitializeGraph;
begin
  G.Head := nil;
  G.Tail := nil;
  G.Order := 0;
end;

procedure DestroyGraph;
var
  Node: TPNode;
begin

  // Цикл А1. Освобождение списка вершин
  while G.Head <> nil do
  begin
    Node := G.Head;

    // Цикл А2. Освобождение списка соседей вершины
    DestroyList(Node.Head);

    G.Head := G.Head.Next;
    Dispose(Node);
  end; // Конец А1
end;

function RestorePath(const Parents: array of Cardinal; u, v: Integer): TStack;
begin

  InitializeStack(Result); // Инициализация стека

  // Цикл А1. Добавление очередного предка в пути
  while u <> v do
  begin
    Push(Result, v);
    v := Parents[v - 1];
  end; // Конец А1
  Push(Result, u);

end;

function DFS;
var
  Node: TPNode;
  Neighbour: TAdjList;
  Stack: TStack;
  isFound: Boolean;
  Parents: Array of Cardinal;
  isVisited: Array of Boolean;
  i: Integer;
  w, StartCopy: Cardinal;
begin

  // Инициализация стека
  InitializeStack(Stack);
  Push(Stack, u);

  // Инициализация массива меток
  SetLength(isVisited, G.Order);
  for i := Low(isVisited) to High(isVisited) do
    isVisited[i] := False;

  // Инциализация массива предков
  SetLength(Parents, G.Order);

  // Цикл А1. Извлечение элементов из стека до нахождения вершины
  StartCopy := u; // Сохранение начала пути
  isFound := u = v;
  while not(isEmpty(Stack) or isFound) do
  begin
    // Получение вершины
    u := Pop(Stack);
    if not isVisited[u - 1] then
    begin

      // Посещение вершины
      isVisited[u - 1] := true;
      isFound := u = v;

      // Цикл А2. Сохранение соседей в стек
      Node := GetByNumber(G, u);
      Neighbour := Node.Head;
      while not((Neighbour = nil) or isFound) do
      begin
        w := Neighbour.Elem;
        // Получение очередного соседа

        // Добавление в стек непосещённых вершин
        if not isVisited[w - 1] then
        begin
          Push(Stack, w); // Вставка вершины в стек
          Parents[w - 1] := u; // Сохранение пути
        end; // Конец if

        Neighbour := Neighbour.Next; // Переход к следующему соседу
      end; // Конец А2

    end; // Конец if

  end; // Конец А1

  DestroyList(Stack); // Очистка стека

  // Восстановление пути
  InitializeStack(Result);
  if isFound then
    Result := RestorePath(Parents, StartCopy, v);
end;

function BFS;
var
  Node: TPNode;
  Neighbour: TAdjList;
  Queue: TQueue;
  i: Cardinal;
  isVisited: Array of Boolean;
  Parents: Array of Cardinal;
  StartCopy: Cardinal;
  w: Cardinal;
  isFound: Boolean;
begin

  // Инициализация очереди
  InitializeQueue(Queue);
  Enqueue(Queue, u);

  // Инициализация массива меток
  SetLength(isVisited, G.Order);
  for i := Low(isVisited) to High(isVisited) do
    isVisited[i] := False;

  // Инициализация массива предков
  SetLength(Parents, G.Order);

  // Цикл А1. Извлечение из очереди вершин
  StartCopy := u;
  isFound := u = v;
  while not(isEmpty(Queue.Head) or isFound) do
  begin
    u := Dequeue(Queue);
    if not isVisited[u - 1] then
    begin

      // Посещение вершины
      isVisited[u - 1] := true;
      isFound := u = v;

      // Цикл А2. Вставка в очередь соседей вершины
      Node := GetByNumber(G, u);
      Neighbour := Node.Head;
      while not((Neighbour = nil) or isFound) do
      begin
        w := Neighbour.Elem;
        if not isVisited[w - 1] then
        begin
          Enqueue(Queue, w); // Запись в очередь
          Parents[w - 1] := u; // Сохранение пути
        end; // Конец if
        Neighbour := Neighbour.Next;
      end; // Конец А2

    end; // Конец if

  end; // Конец А1

  // Очистка очереди
  DestroyList(Queue.Head);

  // Восстановление пути
  InitializeStack(Result);
  if isFound then
    Result := RestorePath(Parents, StartCopy, v);

end;

function Dijkstra;
var
  Node: TPNode;
  Neighbour: TAdjList;
  isVisited: Array of Boolean;
  Marks: Array of Integer;
  i: Cardinal;
  w: Cardinal;
  Parents: Array of Cardinal;
  StartCopy: Cardinal;
  isFound: Boolean;
  d: Cardinal;
  AdjMatrix: TAdjMatrix;
begin

  ToAdjMatrix(G, AdjMatrix);

  // Инициализация меток
  SetLength(Marks, G.Order);
  for i := Low(Marks) to High(Marks) do
    Marks[i] := AdjMatrix[u - 1, i];

  // Инициализация массива меток
  SetLength(isVisited, G.Order);
  for i := Low(isVisited) to High(isVisited) do
    isVisited[i] := False;

  // Инициализация массива предков
  SetLength(Parents, G.Order);

  StartCopy := u;
  isFound := False;
  d := 0;

  while not(isFound or (d = INFINITY)) do
  begin
    MinDist(Marks, isVisited, u, d);
    isFound := u = v;
    isVisited[u - 1] := true;

    // TODO 3: Проход по циклу в случае, когда вершина найдена
    for w := 0 to G.Order - 1 do
    begin
      if not isVisited[w] and (Marks[w] > d + AdjMatrix[u - 1, w]) then
      begin
        Marks[w] := d + AdjMatrix[u - 1, w];
        Parents[w] := u;
      end;

    end;
  end;

  // Восстановление пути
  InitializeStack(Result);
  if isFound then
    Result := RestorePath(Parents, StartCopy, v);

end;

procedure ToAdjMatrix;
var
  i: Integer;
  Node: TPNode;
  Neighbour: TPList;
  j: Integer;
begin

  // Инициализация матрицы
  SetLength(Matrix, G.Order, G.Order);

  // Цикл А1. Проход по вершинам
  Node := G.Head;
  for i := 0 to G.Order - 1 do
  begin

    // Цикл А2. Проход по соседям
    Neighbour := Node.Head;
    for j := 0 to G.Order - 1 do
    begin

      // Проверка смежности вершин
      if (Neighbour <> nil) and (Neighbour.Elem = j + 1) then
      begin

        // Вершины были смежны
        Matrix[i, j] := 1;

        // Переход к следующему соседу
        Neighbour := Neighbour.Next;
      end
      else
        Matrix[i, j] := INFINITY;
      // Вершины не были смежными
    end; // Конец А2
    Matrix[i, i] := 0;

    // Переход к следующей вершине
    Node := Node.Next;
  end; // Конец А1
end;

end.
