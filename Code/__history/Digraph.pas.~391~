unit Digraph;

interface

uses System.Types, DynStructures, System.SysUtils;

const
  INFINITY = 1000000;

type

  // Тип перечисления стиля вершин
  TDesign = (dgPassive, dgActive, dgVisited);

  // Тип списка смежности
  TPAdjVertice = TPItem;

  // Тип вершины графа
  TPVertice = ^TVertice;

  TVertice = record
    Center: TPoint;
    Number: Integer;
    Head: TPAdjVertice;
    Next: TPVertice;
    Deg: Integer;
    Design: TDesign;
  end;

  // Тип ориентированный граф
  TGraph = record
    Head: TPVertice;
    Order: Integer;
  end;

  // Тип матрицы весов
  TWeights = array of array of Integer;

  { Процедура получения вершины по номеру }
procedure GetByNumber(const G: TGraph; v: Integer; out Vertice: TPVertice);

{ Функция проверки вершин на смежность }
function AreAdjacent(const G: TGraph; v, u: Integer): Boolean;

{ Процедура нахождения вершины по точке на холсте }
procedure Centralize(const G: TGraph; const P: TPoint; R: Integer;
  out Vertice: TPVertice);

{ Функция вычисления расстояния между двумя точками в пикселях }
function Distance(const p1, p2: TPoint): Integer;

{ Процедура добавления вершины в граф }
procedure AddVertice(var G: TGraph; const C: TPoint);

{ Процедура добавления дуги в граф }
procedure AddArc(var G: TGraph; v, u: Integer);

{ Процедура удаления вершины из графа }
procedure DeleteVertice(var G: TGraph; v: Integer);

{ Процедура удаления дуги из графа }
procedure DeleteArc(var G: TGraph; v, u: Integer);

{ Процедура инициализации графа }
procedure InitializeGraph(var G: TGraph);

{ Процедура очищения графа }
procedure DestroyGraph(var G: TGraph);

{ Процедура преобразования графа в матрицу весов }
procedure ToWeightMatrix(const G: TGraph; out Matrix: TWeights);

implementation

{ Функция нахождения расстояния между точками на картинке }
function Distance(const p1, p2: TPoint): Integer;
begin
  Result := Round(Sqrt(Sqr(p2.x - p1.x) + Sqr(p2.y - p1.y)));
end;

procedure GetByNumber(const G: TGraph; v: Integer; out Vertice: TPVertice);
begin
  Vertice := G.Head;
  while (Vertice <> nil) and (Vertice.Number <> v) do
    Vertice := Vertice.Next;
end;

procedure Centralize(const G: TGraph; const P: TPoint; R: Integer;
  out Vertice: TPVertice);
var
  isFound: Boolean;
begin
  Vertice := G.Head;
  isFound := (Vertice = nil) or (Distance(Vertice.Center, P) <= R);

  // Цикл А1. Поиск последней вершины с близкими координатами
  while not isFound and (Vertice.Next <> nil) do
  begin
    Vertice := Vertice.Next;
    isFound := Distance(Vertice.Center, P) <= R;
  end; // Конец А1

  if not isFound then
    Vertice := nil;

end;

procedure AddVertice(var G: TGraph; const C: TPoint);
var
  Vertice: TPVertice;
begin
  Inc(G.Order);

  // Инициализация новой вершины
  New(Vertice);
  with Vertice^ do
  begin
    Center := C;
    Number := G.Order;
    Head := nil;
    Next := G.Head;
    Deg := 0;
    Design := dgPassive;
  end;

  // Запись новой вершины
  G.Head := Vertice;

end;

procedure AddArc(var G: TGraph; v, u: Integer);
var
  Vertice: TPVertice;
  PrevArc, Arc: TPAdjVertice;
  isFound: Boolean;
begin

  // Получение вершины
  GetByNumber(G, v, Vertice);
  Inc(Vertice.Deg);

  // Сохранение соседа в список смежности
  Push(Vertice.Head, u);

end;

procedure DeleteVertice(var G: TGraph; v: Integer);
var
  PrevVertice, Vertice: TPVertice;
  PrevArc, Arc: TPAdjVertice;
begin
  Dec(G.Order);
  if v = G.Head.Number then
  begin
    Vertice := G.Head;
    G.Head := G.Head.Next;
  end
  else
  begin
    GetByNumber(G, v + 1, PrevVertice);
    Vertice := PrevVertice.Next;
    PrevVertice.Next := Vertice.Next;
  end;

  DestroyList(Vertice.Head);
  Dispose(Vertice);

  Vertice := G.Head;
  while Vertice <> nil do
  begin
    if Vertice.Number > v then
      Dec(Vertice.Number);

    PrevArc := nil;
    Arc := Vertice.Head;
    while Arc <> nil do
    begin
      if Arc.Number = v then
      begin
        if PrevArc = nil then
          Vertice.Head := Arc.Next
        else
          PrevArc.Next := Arc.Next;
        Dispose(Arc);
      end
      else if Arc.Number > v then
        Dec(Arc.Number);

      PrevArc := Arc;
      Arc := Arc.Next;
    end;
    Vertice := Vertice.Next;
  end;
end;

procedure DeleteArc(var G: TGraph; v, u: Integer);
var
  Vertice: TPVertice;
  Arc, PrevArc: TPAdjVertice;
  isFound: Boolean;
begin

  // Получение начала дуги
  GetByNumber(G, v, Vertice);

  Dec(Vertice.Deg);

  // Получение первого соседа
  PrevArc := Vertice.Head;
  Arc := nil;

  // Поиск звена перед звеном с искомым соседом
  if (PrevArc = nil) or (PrevArc.Number = u) then
  begin
    if PrevArc <> nil then
      Vertice.Head := PrevArc.Next
    else
      Vertice.Head := nil;
  end
  else
  begin

    isFound := (PrevArc.Next.Number = u) or (PrevArc = nil);

    // Получение предыдущего соседа удаляемого
    while not isFound do
    begin
      PrevArc := PrevArc.Next;
      isFound := (PrevArc = nil) or (PrevArc.Next.Number = u);
    end;

    Arc := PrevArc.Next;
    PrevArc.Next := Arc.Next;
  end;

  // Удаление соседа
  if not(Arc = nil) then
  begin
    Dispose(Arc);
  end;

end;

procedure InitializeGraph(var G: TGraph);
begin
  G.Head := nil;
  G.Order := 0;
end;

procedure DestroyGraph(var G: TGraph);
var
  Vertice: TPVertice;
begin

  // Цикл А1. Освобождение списка вершин
  while G.Head <> nil do
  begin
    Vertice := G.Head;

    // Цикл А2. Освобождение списка соседей вершины
    DestroyList(Vertice.Head);

    G.Head := G.Head.Next;
    Dispose(Vertice);
  end; // Конец А1
end;

procedure ToWeightMatrix(const G: TGraph; out Matrix: TWeights);
var
  v, u: Integer;
  Vertice: TPVertice;
  Arc: TPAdjVertice;
begin

  // Инициализация матрицы
  SetLength(Matrix, G.Order, G.Order);

  for v := 1 to G.Order do
  begin
    for u := 1 to G.Order do
      Matrix[v - 1, u - 1] := INFINITY;
  end;

  // Цикл А2. Проход по вершинам
  Vertice := G.Head;
  while Vertice <> nil do
  begin

    // Цикл B2. Сохранение весов существующих рёбер
    Arc := Vertice.Head;
    while Arc <> nil do
    begin
      Matrix[Vertice.Number - 1, Arc.Number - 1] := 1;
      Arc := Arc.Next;
    end; // Конец B2

    // Переход к следующей вершине
    Vertice := Vertice.Next;
  end; // Конец А1
end;

function AreAdjacent(const G: TGraph; v, u: Integer): Boolean;
var
  Vertice: TPVertice;
  AdjVertice: TPAdjVertice;
begin
  Result := false;
  GetByNumber(G, v, Vertice);
  AdjVertice := Vertice.Head;
  while not Result and (AdjVertice <> nil) do
  begin
    Result := AdjVertice.Number = u;
    AdjVertice := AdjVertice.Next;
  end;
end;

end.
