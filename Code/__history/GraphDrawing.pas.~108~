unit GraphDrawing;

interface

uses Digraph, System.Types, Math, VCL.Graphics, DynStructures;

type
  ArcLine = Array [1 .. 5] of TPoint;

procedure Visit(var G: TGraph; var Path: TStack);

procedure MakePassive(var G: TGraph);

procedure RedrawGraph(const Img: TCanvas; Width, Height: Integer;
  const G: TGraph);

implementation

procedure GetArcPoints(c1, c2: TPoint; R: Integer; out p: ArcLine);
const
  ArrAngle = (45 / 180) * pi;
var
  StartX, StartY: Integer;
  EndX, EndY: Integer;
  d: Integer;
  deltaX, deltaY: Integer;
  LineAngle: Real;
  Sign: Integer;
begin
  d := Distance(c1, c2);
  EndX := Round(c2.x + R * (c1.x - c2.x) / d);
  EndY := Round(c2.y + R * (c1.y - c2.y) / d);

  StartX := Round(c1.x + R * (c2.x - c1.x) / d);
  StartY := Round(c1.y + R * (c2.y - c1.y) / d);

  p[1].x := StartX;
  p[1].y := StartY;

  p[2].x := EndX;
  p[2].y := EndY;

  p[4] := p[2];

  LineAngle := ArcSin((StartY - EndY) / (Distance(p[1], p[2]) + 1));

  if (StartX - EndX) <> 0 then
    Sign := Round((StartX - EndX) / abs(StartX - EndX))
  else
    Sign := 1;

  p[3].x := EndX + Sign * trunc(cos(ArrAngle - Sign * LineAngle) * (R div 2));
  p[3].y := EndY - Sign * trunc(sin(ArrAngle - Sign * LineAngle) * (R div 2));

  p[5].x := EndX + Sign * trunc(cos(ArrAngle + Sign * LineAngle) * (R div 2));
  p[5].y := EndY + Sign * trunc(sin(ArrAngle + Sign * LineAngle) * (R div 2));
end;

procedure DrawVertice(const Img: TCanvas; R: Integer; const Vertice: TPVertice);
var
  Caption: String;
  PosX: Integer; // Левый верхний край текста
  Copy: Integer; // Копия номера вершины
begin

  // Получение имени вершины и его x-координаты
  Str(Vertice.Number, Caption);
  Copy := Vertice.Number;
  PosX := Vertice.Center.x;
  while Copy <> 0 do
  begin
    Copy := Copy div 10;
    PosX := PosX - 5;
  end;

  with Img do
  begin
    case Vertice.Design of
      dgPassive:
        begin
          Pen.Color := clBlack;
          Font.Color := clBlack;
          Brush.Color := clWhite;
        end;
      dgActive:
        begin
          Pen.Color := clRed;
          Font.Color := clBlack;
          Brush.Color := clCream;
        end;
      dgVisited:
        begin
          Pen.Color := clTeal;
          Font.Color := clWhite;
          Brush.Color := clLime;
        end;
    end;

    // Вывод круга
    with Vertice.Center do
      Ellipse(x - R, y - R, x + R, y + R);

    // Вывод имени вершины
    TextOut(PosX - 2, Vertice.Center.y - 10, Caption);

    // Возврат значений пера и заливки
    Pen.Color := clBlack;
    Brush.Color := clWhite;
  end;

end;

procedure DrawArc(const Img: TCanvas; R: Integer; const c1, c2: TPoint;
  const Neighbour: TPAdjVertice);
var
  d: Integer;
  Points: ArcLine;
  WeightString: String;
  MiddleX, MiddleY: Integer;
  StringHeight, StringWidth: Integer;
begin

  d := Distance(c1, c2);
  if d > R then
  begin

    // Инициализация данных для рисования
    with Img do
    begin
      if Neighbour.isVisited then
        Pen.Color := clTeal
      else
        Pen.Color := clBlack;

      GetArcPoints(c1, c2, R, Points);
      Str(Neighbour.Weight, WeightString);
      StringWidth := TextWidth(WeightString);
      StringHeight := TextHeight(WeightString);
      MiddleX := (Points[1].x + Points[2].x - StringWidth) div 2;
      MiddleY := (Points[1].y + Points[2].y - StringHeight) div 2;

      // Рисование дуги и веса
      Polyline(Points);
      Rectangle(MiddleX, MiddleY, MiddleX + StringWidth + 1,
        MiddleY + StringHeight + 1);
      TextOut(MiddleX, MiddleY, WeightString);
    end;
  end;

end;

procedure Visit;
var
  Vertice, Neighbour: TPVertice;
  AdjVertice: TPAdjVertice;
  v, u: Integer;
begin
  while Path <> nil do
  begin
    v := Pop(Path);
    GetByNumber(G, v, Vertice);
    Vertice.Design := dgVisited;
    if Path <> nil then
    begin
      u := Pop(Path);

      // Посещение ребра
      AdjVertice := Vertice.Head;
      while u <> AdjVertice.Number do
        AdjVertice := AdjVertice.Next;
      AdjVertice.isVisited := true;

      Push(Path, u);
    end;
  end;
  G.isPainted := true;
end;

procedure MakePassive;
var
  Vertice: TPVertice;
  AdjVertice: TPAdjVertice;
begin
  Vertice := G.Head;
  while Vertice <> nil do
  begin
    Vertice.Design := dgPassive;
    AdjVertice := Vertice.Head;
    while AdjVertice <> nil do
    begin
      AdjVertice.isVisited := false;
      AdjVertice := AdjVertice.Next;
    end;

    Vertice := Vertice.Next;
  end;
  G.isPainted := false;
end;

procedure RedrawGraph;
var
  Vertice, AdjVertice, Active: TPVertice;
  Arc: TPAdjVertice;
begin
  with Img do
  begin
    Pen.Color := clWhite;
    Rectangle(0, 0, Width, Height);
    Pen.Color := clBlack;
    Pen.Width := 3;
    Font.Size := 15;
    Font.Style := [fsBold];
  end;

  // Прорисовка дуг
  Vertice := G.Head;
  while Vertice <> nil do
  begin
    Arc := Vertice.Head;
    while Arc <> nil do
    begin
      GetByNumber(G, Arc.Number, AdjVertice);
      DrawArc(Img, G.R, Vertice.Center, AdjVertice.Center, Arc);
      Arc := Arc.Next;
    end;
    Vertice := Vertice.Next;
  end;

  // Прорисовка вершин
  Vertice := G.Head;
  while Vertice <> nil do
  begin
    DrawVertice(Img, G.R, Vertice);
    if Vertice.Design = dgActive then
      Active := Vertice;
    Vertice := Vertice.Next;
  end;
  if Active <> nil then
    DrawVertice(Img, G.R, Active);

end;

end.
